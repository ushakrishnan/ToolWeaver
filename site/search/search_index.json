{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ToolWeaver","text":"<p>Secure tool orchestration for AI\u2014parallel agents, caching, and sandboxed execution with built-in guardrails.</p>"},{"location":"#simple-explanation","title":"Simple Explanation","text":"<p>Plan once with a large model, then execute many small, safe steps. ToolWeaver finds the right tools and runs them in parallel with limits and caching, so you get fast results without runaway cost.</p>"},{"location":"#technical-explanation","title":"Technical Explanation","text":"<p>Planner outputs a DAG; the orchestrator discovers tools, narrows via hybrid search (BM25 + embeddings), dispatches steps concurrently with semaphores and guardrails, retries/fallbacks on errors, aggregates outputs, and records metrics. Code runs in a sandbox with restricted builtins and timeouts.</p>"},{"location":"#the-product-pitch","title":"The Product Pitch","text":"<ul> <li>Problem: Orchestrating many tools/models safely is hard\u2014costs, concurrency, safety, and consistency.</li> <li>Solution: ToolWeaver provides secure fan-out, discovery, safe execution, and performance primitives.</li> <li>Value: Ship faster, scale safely, stay flexible with decorators/templates/YAML.</li> </ul>"},{"location":"#get-started","title":"Get Started","text":"<ul> <li>Quickstart: Get Started / Quickstart \u2014 install, define your first tool, and run a parallel demo.</li> <li>Why ToolWeaver: Product / Why ToolWeaver \u2014 the problem, our approach, and value for production teams.</li> <li>Use Cases: Product / Use Cases \u2014 batch processing, ensemble voting, discovery, safety, and cost control.</li> </ul>"},{"location":"#10-minute-quickstart","title":"10-Minute Quickstart","text":"<p>Your first tool and parallel run</p> <ol> <li>Install: <code>pip install toolweaver</code></li> <li>Define a tool:    <code>python    from orchestrator import mcp_tool    @mcp_tool(domain=\"demo\")    async def echo(message: str) -&gt; dict:        return {\"echo\": message}</code></li> <li>Run a parallel demo:    <code>bash    python samples/25-parallel-agents/parallel_deep_dive.py</code></li> </ol>"},{"location":"#learn","title":"Learn","text":"<ul> <li>Overview: Concepts / Overview \u2014 core ideas: tools, discovery, sandbox, parallel dispatch, caching.</li> <li>How it works: Product / How It Works \u2014 end-to-end architecture with dispatch, aggregation, and caching.</li> <li>Security: Product / Security &amp; Safety \u2014 redaction, sanitization, sandboxing, quotas, and idempotency.</li> <li>Performance: Product / Performance &amp; Cost \u2014 caching strategy, circuit breakers, and speedups.</li> </ul>"},{"location":"#build","title":"Build","text":"<ul> <li>Python API: Reference / Python API \u2014 decorators, templates, loaders, discovery, plugins, config, logging, A2A.</li> <li>REST API: Reference / API (REST) / Overview \u2014 list/get/execute endpoints for exposing tools over HTTP.</li> <li>Tutorials: Sandbox Execution \u2014 safe code runs; Caching Deep Dive \u2014 TTL + fallback; Parallel Agents \u2014 fan-out with guardrails.</li> <li>Samples: Samples Index \u2014 curated runnable demos to see real behavior quickly.</li> </ul>"},{"location":"#preview-locally","title":"Preview Locally","text":"<pre><code>pip install mkdocs-material\nmkdocs serve\n</code></pre>"},{"location":"concepts/","title":"Concepts","text":"<ul> <li>Overview</li> </ul>"},{"location":"concepts/overview/","title":"Concepts Overview","text":"<p>Core ideas that shape ToolWeaver:</p>"},{"location":"concepts/overview/#simple-explanation","title":"Simple Explanation","text":"<p>ToolWeaver helps you define tools, organize them into a catalog, and lets agents find and run them safely and efficiently. Sandboxed execution isolates tool code, parallel agents scale out work, and caching speeds up common operations. Skills and plugins make sharing and extension easy.</p>"},{"location":"concepts/overview/#technical-explanation","title":"Technical Explanation","text":"<p>Concepts map to system components: registration and discovery form a searchable catalog (including semantic search), sandbox enforces isolation and timeouts, parallel dispatch manages concurrency with quotas and idempotency caching, and a multi-tier cache (Redis + file) backs catalogs, embeddings, and execution guardrails. Skills package tools for reuse; plugins extend registries and runtimes.</p> <ul> <li>Tools: Functions or external actions registered via <code>@mcp_tool</code>, <code>@tool</code>, or templates.</li> <li>Discovery: Catalog and search tools by domain, keywords, or semantics.</li> <li>Sandboxed execution: Isolated code paths with restricted builtins and timeouts.</li> <li>Parallel agents: Fan out tasks with semaphores, quotas, and idempotency caching.</li> <li>Caching: Multi-tier cache (Redis + file fallback) for tool catalogs, search, embeddings, idempotency.</li> <li>Skills and plugins: Share tools as skills; extend via plugin registry.</li> </ul> <p>Key references: - Sandbox implementation: orchestrator/_internal/execution/sandbox.py - Parallel dispatch: orchestrator/tools/sub_agent.py - Caching: orchestrator/_internal/infra/redis_cache.py - Public API surface: reference/api.md</p>"},{"location":"deployment/","title":"Deployment Guides","text":"<p>Use these runbooks to deploy ToolWeaver in different environments. Pick the guide that matches your stack and maturity level.</p> <ul> <li>Production Deployment \u2014 End-to-end hardening, performance, monitoring, and scaling.</li> <li>Azure Setup \u2014 Configure Azure Computer Vision OCR for receipt flows.</li> <li>Redis Setup \u2014 Caching options: local, WSL, Azure Cache, Redis Cloud.</li> <li>Qdrant Setup \u2014 Vector DB options: local, WSL, Qdrant Cloud, Azure ACI.</li> <li>SQLite + Grafana / OTLP \u2014 Analytics backends (SQLite, Prometheus, Grafana Cloud OTLP).</li> </ul>"},{"location":"deployment/azure-setup/","title":"Azure Computer Vision Setup","text":"<p>Use Azure Computer Vision OCR (Read API) for receipt extraction; mock mode stays available for tests.</p>"},{"location":"deployment/azure-setup/#option-1-mock-mode-default","title":"Option 1: Mock mode (default)","text":"<p>No setup needed. Uses fake receipt data.</p>"},{"location":"deployment/azure-setup/#option-2-real-azure-computer-vision","title":"Option 2: Real Azure Computer Vision","text":"<ol> <li>Create resource in Azure Portal \u2192 Computer Vision (choose region, name, pricing tier).</li> <li>Get credentials: endpoint + key.</li> <li>Configure env:</li> </ol> <pre><code>AZURE_CV_ENDPOINT=https://your-resource.cognitiveservices.azure.com/\nAZURE_CV_KEY=your-key\nOCR_MODE=azure\n</code></pre> <ol> <li>Install deps: <code>pip install -e .</code> (from repo root).</li> <li>Test: <code>python run_demo.py</code> (or your receipt workflow).</li> </ol> <p>Pricing (Read API) - Free F0: 5,000 tx/mo, 20/min. - S1: ~$1 per 1k (first 1M), cheaper at higher volumes.</p> <p>Using your own images Update the input plan with your image URL (JPG/PNG/BMP/PDF first page, &lt;=50 MB).</p> <p>Security best practices - Keep <code>.env</code> out of git; rotate keys; prefer Key Vault in production; enable Azure Monitor + spending alerts.</p> <p>Troubleshooting - \"credentials not configured\": check env vars + OCR_MODE. - Module missing: install requirements. - Access denied: verify key/region and subscription status. - Local images: host via blob SAS or any temporary HTTPS URL.</p> <p>Switching modes - Mock: <code>OCR_MODE=mock</code> (or unset) - Azure: <code>OCR_MODE=azure</code></p>"},{"location":"deployment/production-deployment/","title":"Production Deployment Guide","text":"<p>Covers security hardening, performance, monitoring, scaling, and troubleshooting for production rollouts.</p>"},{"location":"deployment/production-deployment/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python: 3.11+</li> <li>RAM: 2 GB minimum (4 GB recommended if you run local embeddings)</li> <li>CPU: 2+ cores recommended for parallel tool execution</li> <li>Storage: ~1 GB for models and cache</li> </ul>"},{"location":"deployment/production-deployment/#dependencies-baseline","title":"Dependencies (baseline)","text":"<pre><code>pip install pydantic&gt;=2.0\npip install aiohttp&gt;=3.13\n# Azure OpenAI (required)\npip install azure-identity&gt;=1.12\npip install openai&gt;=1.0\n# Semantic search (optional but recommended)\npip install sentence-transformers&gt;=5.0\npip install rank-bm25&gt;=0.2\npip install torch&gt;=2.0\npip install scikit-learn&gt;=1.8\n# Testing (dev only)\npip install pytest&gt;=9.0\npip install pytest-asyncio&gt;=1.3\npip install pytest-mock&gt;=3.15\n</code></pre>"},{"location":"deployment/production-deployment/#security-hardening","title":"Security Hardening","text":""},{"location":"deployment/production-deployment/#code-execution-sandbox","title":"Code execution sandbox","text":"<p>Already implemented via <code>ProgrammaticToolExecutor</code>; ensure timeouts and call limits are set.</p> <pre><code>from orchestrator.programmatic_executor import ProgrammaticToolExecutor\nexecutor = ProgrammaticToolExecutor(tool_catalog=catalog, mcp_client=mcp_client, timeout=30, max_tool_calls=100)\n</code></pre> <p>Blocked: file system, network, process spawn, eval/exec, dangerous builtins.</p>"},{"location":"deployment/production-deployment/#azure-ad-authentication","title":"Azure AD authentication","text":"<p>Prefer Managed Identity/Workload Identity over API keys.</p> <pre><code>from azure.identity import DefaultAzureCredential\ncredential = DefaultAzureCredential()\n</code></pre> <p>Use RBAC and token auto-renewal; avoid embedding keys.</p>"},{"location":"deployment/production-deployment/#input-validation","title":"Input validation","text":"<p>Use Pydantic models with length limits and pattern checks where needed.</p>"},{"location":"deployment/production-deployment/#resource-limits","title":"Resource limits","text":"<p>Set per-call timeouts, max concurrency, and rate limits (Redis or in-memory). Example: <code>TOOL_TIMEOUT=30</code>, <code>MAX_CONCURRENT_TOOLS=10</code>, <code>REQUESTS_PER_MINUTE=60</code>.</p>"},{"location":"deployment/production-deployment/#performance","title":"Performance","text":""},{"location":"deployment/production-deployment/#lazy-loading","title":"Lazy loading","text":"<p>Defer heavy inits (e.g., search engine) until first use.</p>"},{"location":"deployment/production-deployment/#caching","title":"Caching","text":"<p>Use multi-level caching (discovery, embeddings, queries, prompt cache). Configure TTLs to balance freshness and cost.</p>"},{"location":"deployment/production-deployment/#connection-pooling","title":"Connection pooling","text":"<p>Reuse <code>aiohttp</code> sessions with sensible connection limits when calling external services.</p>"},{"location":"deployment/production-deployment/#parallel-execution","title":"Parallel execution","text":"<p>Use <code>asyncio.gather(..., return_exceptions=True)</code> for independent tool calls.</p>"},{"location":"deployment/production-deployment/#analytics-monitoring","title":"Analytics &amp; Monitoring","text":"<p>Choose one backend via env vars: - Prometheus (self-hosted scraping) - OTLP (Grafana Cloud push) - SQLite (local dev)</p> <pre><code>ANALYTICS_BACKEND=prometheus   # or otlp or sqlite\n</code></pre> <p>Create the client via <code>create_analytics_client()</code>; metrics include success/failure/latency/ratings/health scores. Prefer Prometheus/OTLP over legacy execution logging.</p> <p>Expose health/metrics endpoints for probes and scraping (FastAPI example):</p> <pre><code>@app.get(\"/health\")\nasync def health():\n    return {\"status\": \"healthy\"}\n</code></pre> <p>Add <code>/metrics</code> when using Prometheus backend.</p>"},{"location":"deployment/production-deployment/#scaling","title":"Scaling","text":"<ul> <li>Stateless app: keep request state out of process; share cache over NFS/Azure Files.</li> <li>Horizontal scale behind a load balancer; no sticky sessions required.</li> <li>Kubernetes resource requests: start around 1 CPU/2 GiB; allow headroom for caches.</li> <li>Shared cache PVC for embeddings/catalog if using file cache.</li> </ul>"},{"location":"deployment/production-deployment/#deployment-patterns","title":"Deployment patterns","text":"<ul> <li>Containers + Kubernetes (preferred): add liveness/readiness probes; mount cache volume if needed; configure secrets via K8s secrets/Key Vault.</li> <li>Azure App Service/Container Apps: ensure Managed Identity enabled for Azure OpenAI; configure env vars for Redis/Qdrant.</li> </ul>"},{"location":"deployment/production-deployment/#troubleshooting-quick-checks","title":"Troubleshooting quick checks","text":"<ul> <li>Health: hit <code>/health</code></li> <li>Metrics: <code>/metrics</code> when Prometheus enabled</li> <li>Cache status: Redis/Qdrant reachable? fall back behaviors enabled?</li> <li>Timeouts: confirm per-tool timeout and global request timeouts</li> <li>Credentials: prefer Managed Identity; if keys, verify env vars loaded</li> </ul>"},{"location":"deployment/qdrant-setup/","title":"Qdrant Setup Guide","text":"<p>Vector database options for semantic search.</p>"},{"location":"deployment/qdrant-setup/#option-1-local-qdrant-via-docker","title":"Option 1: Local Qdrant via Docker","text":"<pre><code># From repo root\ndocker compose up -d qdrant\n# Verify\ncurl http://localhost:6333/collections\n# Configure\nQDRANT_URL=http://localhost:6333\nQDRANT_API_KEY=\n</code></pre> <p>Data persists in <code>./qdrant_data</code> if configured in compose.</p>"},{"location":"deployment/qdrant-setup/#option-2-local-qdrant-via-wsl-2","title":"Option 2: Local Qdrant via WSL 2","text":"<p>Run the container in WSL Docker, find the WSL IP (e.g., <code>ip addr show eth0</code>), then configure:</p> <pre><code>QDRANT_URL=http://&lt;wsl-ip&gt;:6333\nQDRANT_API_KEY=\n</code></pre>"},{"location":"deployment/qdrant-setup/#option-3-qdrant-cloud-free-tier-recommended-for-dev","title":"Option 3: Qdrant Cloud (Free Tier) \u2014 recommended for dev","text":"<ul> <li>Create free 1 GB cluster at https://cloud.qdrant.io (\u2248100k vectors, ~2.6k tools at 384-dim).</li> <li>Configure:</li> </ul> <pre><code>QDRANT_URL=https://&lt;cluster&gt;.aws.cloud.qdrant.io\nQDRANT_API_KEY=&lt;key&gt;\n</code></pre> <ul> <li>Create collection <code>toolweaver_tools</code> (384 dims, cosine, dense vector <code>default</code>; sparse not required by code).</li> </ul>"},{"location":"deployment/qdrant-setup/#option-4-azure-container-instances-self-hosted-cloud","title":"Option 4: Azure Container Instances (self-hosted cloud)","text":"<pre><code>az group create --name rg-toolweaver --location eastus\naz container create --resource-group rg-toolweaver --name qdrant-instance --image qdrant/qdrant:latest --cpu 1 --memory 2 --ports 6333 6334 --dns-name-label toolweaver-qdrant --location eastus --restart-policy Always\naz container show --resource-group rg-toolweaver --name qdrant-instance --query \"ipAddress.fqdn\" -o tsv\n</code></pre> <p>Config:</p> <pre><code>QDRANT_URL=http://toolweaver-qdrant.eastus.azurecontainer.io:6333\nQDRANT_API_KEY=&lt;key-if-set&gt;\n</code></pre>"},{"location":"deployment/qdrant-setup/#capacity-monitoring","title":"Capacity &amp; monitoring","text":"<ul> <li>Free tier: 1 GB (~100k vectors @384 dims). Upgrade when you need more.</li> <li>Use Qdrant Cloud dashboard metrics; for self-hosted, expose /metrics if desired.</li> </ul>"},{"location":"deployment/qdrant-setup/#toolweaver-behavior","title":"ToolWeaver behavior","text":"<p><code>VectorToolSearchEngine</code> falls back to in-memory search if Qdrant is unavailable; index the catalog after configuring Qdrant for best results.</p>"},{"location":"deployment/redis-setup/","title":"Redis Setup Guide","text":"<p>Distributed caching options for development through production.</p>"},{"location":"deployment/redis-setup/#option-1-local-redis-via-docker-windowslinuxmacos","title":"Option 1: Local Redis via Docker (Windows/Linux/macOS)","text":"<pre><code># From repo root\ndocker compose up -d redis\n# Verify\ndocker ps | grep redis\n# Configure\nREDIS_URL=redis://localhost:6379\n</code></pre> <p>Stop: <code>docker compose stop redis</code></p>"},{"location":"deployment/redis-setup/#option-2-local-redis-via-wsl-2-windows","title":"Option 2: Local Redis via WSL 2 (Windows)","text":"<p>Install Redis in WSL, bind to 0.0.0.0 if you need Windows access, and set:</p> <pre><code>REDIS_URL=redis://&lt;wsl-ip&gt;:6379\n</code></pre> <p>Test with <code>redis-cli ping</code>.</p>"},{"location":"deployment/redis-setup/#option-3-redis-cloud-free-tier-good-for-dev","title":"Option 3: Redis Cloud (Free Tier) \u2014 good for dev","text":"<ul> <li>Create free db at https://redis.io/cloud (30 MB limit).</li> <li>Configure:</li> </ul> <pre><code>REDIS_URL=redis://&lt;host&gt;:&lt;port&gt;\nREDIS_PASSWORD=&lt;password&gt;\n</code></pre> <p>Test with a small Python ping script.</p>"},{"location":"deployment/redis-setup/#option-4-azure-cache-for-redis-production","title":"Option 4: Azure Cache for Redis (production)","text":"<p>Portal or CLI:</p> <pre><code>az group create --name rg-toolweaver --location eastus\naz redis create --name toolweaver-cache --resource-group rg-toolweaver --location eastus --sku Standard --vm-size C1 --enable-non-ssl-port false\naz redis list-keys --name toolweaver-cache --resource-group rg-toolweaver\n</code></pre> <p>Config:</p> <pre><code>REDIS_URL=rediss://toolweaver-cache.redis.cache.windows.net:6380\nREDIS_PASSWORD=&lt;primary-key&gt;\n</code></pre>"},{"location":"deployment/redis-setup/#monitoring-costs","title":"Monitoring &amp; costs","text":"<ul> <li>Redis Cloud free: 30 MB, great for dev.</li> <li>Azure: C0/C1 for test; Premium for clustering/production.</li> <li>Use Azure Monitor or Redis Cloud dashboards for metrics.</li> </ul>"},{"location":"deployment/redis-setup/#toolweaver-behavior","title":"ToolWeaver behavior","text":"<p><code>RedisCache</code> can fall back to file cache if Redis is unavailable; health checks report availability and circuit breaker state.</p>"},{"location":"deployment/sqlite-grafana-setup/","title":"Analytics Backend Setup","text":"<p>Configure analytics via SQLite (dev), Prometheus (self-hosted), or OTLP (Grafana Cloud).</p>"},{"location":"deployment/sqlite-grafana-setup/#quick-start","title":"Quick start","text":"<p>Set one backend in <code>.env</code>:</p> <pre><code>ANALYTICS_BACKEND=sqlite      # local dev (default)\n# or\nANALYTICS_BACKEND=prometheus  # self-hosted scrape\n# or\nANALYTICS_BACKEND=otlp        # Grafana Cloud push\n</code></pre> <p>Install extras as needed (<code>prometheus-client</code>, or <code>opentelemetry-...</code> for OTLP).</p>"},{"location":"deployment/sqlite-grafana-setup/#otlp-grafana-cloud-recommended-for-managed-prod","title":"OTLP (Grafana Cloud) \u2014 recommended for managed prod","text":"<p>1) Sign up at grafana.com (free tier includes Prometheus/OTLP). 2) In Connections \u2192 Prometheus onboarding \u2192 choose OTLP over HTTP. 3) Capture Endpoint, Instance ID, Token. 4) Configure env:</p> <pre><code>ANALYTICS_BACKEND=otlp\nOTLP_ENDPOINT=https://otlp-gateway-prod-&lt;region&gt;.grafana.net/otlp\nOTLP_INSTANCE_ID=&lt;id&gt;\nOTLP_TOKEN=&lt;token&gt;\nOTLP_PUSH_INTERVAL=60\n</code></pre> <p>5) Send metrics:</p> <pre><code>from orchestrator.execution.analytics import OTLPMetrics\nmetrics = OTLPMetrics()\nmetrics.record_skill_execution(\"test_skill\", success=True, latency_ms=150)\n</code></pre> <p>6) View in Grafana Explore (PromQL), e.g., <code>rate(toolweaver_skill_executions_total[5m])</code>.</p> <p>Metrics pushed: executions, successes/failures, latency histogram, rating, health score.</p>"},{"location":"deployment/sqlite-grafana-setup/#prometheus-self-hosted","title":"Prometheus (self-hosted)","text":"<p>1) <code>pip install prometheus-client</code> 2) Env:</p> <pre><code>ANALYTICS_BACKEND=prometheus\nPROMETHEUS_ENABLED=true\nPROMETHEUS_PORT=8000\nPROMETHEUS_HOST=0.0.0.0\n</code></pre> <p>3) Prometheus scrape config:</p> <pre><code>scrape_configs:\n  - job_name: 'toolweaver'\n    static_configs:\n      - targets: ['localhost:8000']\n</code></pre> <p>4) Run Prometheus (docker) and add Grafana dashboards.</p>"},{"location":"deployment/sqlite-grafana-setup/#sqlite-local-dev","title":"SQLite (local dev)","text":"<ul> <li>Zero setup; DB auto-creates at <code>~/.toolweaver/analytics.db</code> when analytics run.</li> <li>Optional envs:</li> </ul> <pre><code>ANALYTICS_DB_PATH=~/.toolweaver/analytics.db\nANALYTICS_DB_RETENTION_DAYS=365\n</code></pre>"},{"location":"deployment/sqlite-grafana-setup/#grafana-cloud-or-self-hosted","title":"Grafana (Cloud or self-hosted)","text":"<ul> <li>For Cloud: create API key/service account; set <code>GRAFANA_URL</code>, <code>GRAFANA_API_KEY</code>, <code>GRAFANA_DATASOURCE_NAME</code> (e.g., ToolWeaver SQLite).</li> <li>For self-hosted: run <code>docker run -d -p 3000:3000 grafana/grafana:latest</code>, create API key, set same envs; datasource type <code>sqlite</code> or your DB type.</li> </ul>"},{"location":"deployment/sqlite-grafana-setup/#verification","title":"Verification","text":"<ul> <li>OTLP: metrics visible in Grafana Explore.</li> <li>Prometheus: GET <code>/metrics</code> and check Prometheus target is up.</li> <li>SQLite: <code>ls ~/.toolweaver/analytics.db</code> and <code>sqlite3</code> to inspect tables if needed.</li> </ul>"},{"location":"developer-guide/","title":"Developer Guide","text":"<ul> <li>Publishing</li> </ul>"},{"location":"developer-guide/publishing/","title":"Publish Docs","text":"<p>This repo uses MkDocs Material for the documentation site.</p>"},{"location":"developer-guide/publishing/#quick-publish-github-pages","title":"Quick Publish (GitHub Pages)","text":"<ul> <li>Ensure Python env and dependencies:</li> </ul> <pre><code>pip install -r requirements.txt\npip install mkdocs-material\n</code></pre> <ul> <li>Build and serve locally:</li> </ul> <pre><code>mkdocs serve\n</code></pre> <ul> <li>Publish to <code>gh-pages</code>:</li> </ul> <pre><code>mkdocs gh-deploy --no-history --message \"Publish docs\"\n</code></pre>"},{"location":"developer-guide/publishing/#github-actions-ci","title":"GitHub Actions (CI)","text":"<p>Add a workflow to build and deploy on push to <code>main</code>:</p> <pre><code>name: Deploy Docs\non:\n  push:\n    branches: [ main ]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-python@v5\n        with:\n          python-version: '3.11'\n      - run: pip install mkdocs-material\n      - run: mkdocs build --strict\n  deploy:\n    needs: build\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-python@v5\n        with:\n          python-version: '3.11'\n      - run: pip install mkdocs-material\n      - run: mkdocs gh-deploy --no-history --message \"Publish docs\"\n</code></pre>"},{"location":"developer-guide/publishing/#tips","title":"Tips","text":"<ul> <li>Only <code>docs/</code> is published; <code>documentation/</code> is legacy/non-public.</li> <li>Set <code>site_url</code>, <code>repo_url</code>, and <code>edit_uri</code> in <code>mkdocs.yml</code>.</li> <li>Use <code>mkdocs build --strict</code> to catch broken links.</li> </ul>"},{"location":"get-started/","title":"Get Started","text":"<p>Pick where to begin:</p> <ul> <li>Quickstart</li> <li>Installation</li> </ul>"},{"location":"get-started/installation/","title":"Installation","text":""},{"location":"get-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10+</li> <li>Optional: Redis for distributed cache (fallback file cache included)</li> </ul>"},{"location":"get-started/installation/#install-from-pypi","title":"Install from PyPI","text":"<pre><code>pip install toolweaver\n</code></pre>"},{"location":"get-started/installation/#optional-extras-choose-what-you-need","title":"Optional extras (choose what you need)","text":"<p>Use extras to pull in integrations without bloating installs.</p> Extra Includes When to use Why <code>toolweaver[redis]</code> redis client deps You have Redis for distributed cache Faster shared caching vs file cache <code>toolweaver[vector]</code> Qdrant/client deps You use semantic search/vector DB Better tool retrieval at scale <code>toolweaver[monitoring]</code> prometheus/otlp/grafana deps You need metrics/export Observability for prod <code>toolweaver[all]</code> All above You want everything preinstalled One-shot setup <p>Env hints - Redis: <code>REDIS_URL=redis://...</code> (or <code>rediss://</code> for TLS) - Vector/Qdrant: <code>QDRANT_URL=...</code>, <code>QDRANT_API_KEY=...</code> - Metrics: <code>ANALYTICS_BACKEND=prometheus|otlp|sqlite</code>, plus backend-specific envs</p>"},{"location":"get-started/installation/#verify","title":"Verify","text":"<pre><code>python - &lt;&lt;\"PY\"\nfrom orchestrator import get_available_tools\nprint(\"Tools loaded:\", len(get_available_tools()))\nPY\n</code></pre>"},{"location":"get-started/quickstart/","title":"Quickstart","text":"<p>Get ToolWeaver running in minutes.</p>"},{"location":"get-started/quickstart/#install","title":"Install","text":"<pre><code>pip install toolweaver\n</code></pre>"},{"location":"get-started/quickstart/#define-a-tool","title":"Define a tool","text":"<pre><code>from orchestrator import mcp_tool\n\n@mcp_tool(domain=\"demo\", description=\"Echo a message\")\nasync def echo(message: str) -&gt; dict:\n    return {\"echo\": message}\n</code></pre>"},{"location":"get-started/quickstart/#list-tools","title":"List tools","text":"<pre><code>from orchestrator import get_available_tools\nprint(get_available_tools())\n</code></pre>"},{"location":"get-started/quickstart/#search-by-domain","title":"Search by domain","text":"<pre><code>from orchestrator import search_tools\nfinance_tools = search_tools(query=\"\", domain=\"finance\")\nprint([t.name for t in finance_tools])\n</code></pre>"},{"location":"get-started/quickstart/#run-a-parallel-dispatch-sample","title":"Run a parallel dispatch (sample)","text":"<p>Use the ready-made sample to see parallel agents with limits:</p> <pre><code>python samples/25-parallel-agents/parallel_deep_dive.py\n</code></pre> <p>See Parallel agents tutorial for expected output.</p>"},{"location":"how-to/","title":"How-to Guides","text":"<p>Task-focused instructions:</p> <ul> <li>Add a Tool</li> <li>Run Parallel Dispatch</li> <li>Use Caching</li> </ul>"},{"location":"how-to/add-a-tool/","title":"How to Add a Tool","text":"<p>1) Decorator (fastest)</p> <pre><code>from orchestrator import mcp_tool\n\n@mcp_tool(domain=\"finance\", description=\"Sum two amounts\")\nasync def add(amount_a: float, amount_b: float) -&gt; dict:\n    return {\"sum\": amount_a + amount_b}\n</code></pre> <p>2) Template class (more control)</p> <pre><code>from orchestrator import FunctionToolTemplate\nfrom orchestrator.shared.models import ToolParameter\n\nclass AddTool(FunctionToolTemplate):\n    name = \"add\"\n    description = \"Sum two amounts\"\n    parameters = [\n        ToolParameter(name=\"amount_a\", type=\"number\", required=True),\n        ToolParameter(name=\"amount_b\", type=\"number\", required=True),\n    ]\n\n    async def run(self, amount_a: float, amount_b: float) -&gt; dict:\n        return {\"sum\": amount_a + amount_b}\n</code></pre> <p>3) YAML (config-driven)</p> <pre><code># add.yaml\nname: add\nprovider: python\nparameters:\n  - name: amount_a\n    type: number\n    required: true\n  - name: amount_b\n    type: number\n    required: true\n</code></pre> <p>Load YAML:</p> <pre><code>from orchestrator import load_tools_from_yaml\nload_tools_from_yaml(\"add.yaml\")\n</code></pre> <p>Check catalog:</p> <pre><code>from orchestrator import search_tools\nprint(search_tools(domain=\"finance\"))\n</code></pre> <p>Full demo: samples/23-adding-new-tools/three_ways.py</p>"},{"location":"how-to/caching/","title":"How to Use Caching","text":"<p>ToolWeaver caches tool catalogs, searches, embeddings, and idempotent agent calls.</p>"},{"location":"how-to/caching/#enable-redis-optional","title":"Enable Redis (optional)","text":"<ul> <li>Set <code>REDIS_URL</code> (TLS supported). If absent, file cache is used automatically.</li> </ul>"},{"location":"how-to/caching/#cache-a-tool-catalog","title":"Cache a tool catalog","text":"<pre><code>from orchestrator import search_tools\n\n# First call populates cache\nprint(search_tools(query=\"\", domain=\"finance\"))\n\n# Subsequent calls are fast and cheap (from cache)\nprint(search_tools(query=\"\", domain=\"finance\"))\n</code></pre>"},{"location":"how-to/caching/#idempotency-for-agent-runs","title":"Idempotency for agent runs","text":"<pre><code>from orchestrator.tools.sub_agent import dispatch_agents\n\nresult = await dispatch_agents(\n    agent_configs=[{\"name\": \"a\", \"template\": \"do {{x}}\", \"arguments\": {\"x\": \"task\"}}],\n    aggregation=\"collect_all\",\n    idempotency_ttl_seconds=3600,\n)\n# Second call reuses cached result\n</code></pre> <p>See deep dive: samples/07-caching-optimization/caching_deep_dive.py</p>"},{"location":"how-to/parallel-dispatch/","title":"How to Run Parallel Dispatch","text":"<p>Use <code>dispatch_agents</code> to fan out calls with guardrails.</p> <pre><code>import asyncio\nfrom orchestrator.tools.sub_agent import dispatch_agents\nfrom orchestrator.tools.sub_agent_limits import DispatchResourceLimits\n\nasync def main():\n    tasks = [\n        {\"name\": \"model_a\", \"template\": \"classify {{text}}\", \"arguments\": {\"text\": \"receipt\"}},\n        {\"name\": \"model_b\", \"template\": \"classify {{text}}\", \"arguments\": {\"text\": \"receipt\"}},\n    ]\n\n    limits = DispatchResourceLimits(max_concurrent=3, max_total_cost_usd=1.0)\n\n    results = await dispatch_agents(\n        agent_configs=tasks,\n        aggregation=\"majority_vote\",\n        limits=limits,\n        idempotency_ttl_seconds=3600,\n    )\n    print(results)\n\nasyncio.run(main())\n</code></pre> <p>Key guards:</p> <p>See the full demo: samples/25-parallel-agents/parallel_deep_dive.py README: samples/25-parallel-agents/README.md</p>"},{"location":"product/","title":"Product","text":"<p>Overview materials:</p> <ul> <li>Overview</li> <li>Project Overview</li> <li>Why ToolWeaver</li> <li>Use Cases</li> <li>How It Works</li> <li>Security &amp; Safety</li> <li>Performance &amp; Cost</li> <li>Comparison &amp; Fit</li> <li>FAQ</li> </ul>"},{"location":"product/comparison/","title":"Comparison &amp; Fit","text":"<p>ToolWeaver vs DIY scripts/frameworks:</p>"},{"location":"product/comparison/#diy-scripts","title":"DIY scripts","text":"<ul> <li>Pros: maximum control, tailored</li> <li>Cons: re-implement guardrails, caching, discovery, observability; hard to scale</li> </ul>"},{"location":"product/comparison/#heavy-frameworks","title":"Heavy frameworks","text":"<ul> <li>Pros: batteries included, rich ecosystems</li> <li>Cons: higher coupling, opinionated runtime; harder to embed in existing apps</li> </ul>"},{"location":"product/comparison/#toolweaver","title":"ToolWeaver","text":"<ul> <li>Library-first: drop into your stack with pip install</li> <li>Focused: orchestrates tools/agents with safety and performance</li> <li>Composable: use decorators, templates, YAML; expose REST when needed</li> </ul> <p>See: - Product Overview - Why ToolWeaver</p>"},{"location":"product/faq/","title":"FAQ","text":""},{"location":"product/faq/#is-toolweaver-a-framework","title":"Is ToolWeaver a framework?","text":"<p>No. It\u2019s a package-first library you embed in your apps.</p>"},{"location":"product/faq/#how-do-i-register-tools","title":"How do I register tools?","text":"<p>Use decorators (<code>@mcp_tool</code>), template classes, or YAML loaders.</p>"},{"location":"product/faq/#can-i-expose-tools-over-http","title":"Can I expose tools over HTTP?","text":"<p>Yes\u2014use the FastAPI adapter to expose REST endpoints.</p>"},{"location":"product/faq/#what-about-safety","title":"What about safety?","text":"<p>Secrets redaction, PII filtering, template sanitization, idempotency, and sandboxed execution are built in.</p>"},{"location":"product/faq/#do-i-need-redis","title":"Do I need Redis?","text":"<p>No. The file cache works by default; Redis adds speed and distribution.</p>"},{"location":"product/faq/#does-it-work-with-planners","title":"Does it work with planners?","text":"<p>Yes. You can use ToolWeaver with planners and agents to select and call tools.</p> <p>See: - Python API - REST API - Tutorials</p>"},{"location":"product/how-it-works/","title":"How It Works","text":""},{"location":"product/how-it-works/#simple-explanation","title":"Simple Explanation","text":"<p>Plan with a large model once, then run many small, safe steps. ToolWeaver finds the right tools and executes them in parallel with guardrails (cost, time, failures), caching results so repeated work is cheap.</p>"},{"location":"product/how-it-works/#technical-explanation","title":"Technical Explanation","text":"<p>Planner produces a DAG of tool steps. The orchestrator discovers tools, narrows via hybrid search (BM25 + embeddings), dispatches steps concurrently with semaphores and limits, retries/fallbacks on errors, aggregates outputs, and records metrics. Code execution runs in a sandbox with restricted builtins and timeouts.</p>"},{"location":"product/how-it-works/#architecture","title":"Architecture","text":"<ol> <li>Register tools (decorators, templates, or YAML)</li> <li>Discover tools (catalog + search)</li> <li>Dispatch agents in parallel with guardrails</li> <li>Aggregate outputs (vote, rank, best)</li> <li>Cache results and enforce idempotency</li> </ol>"},{"location":"product/how-it-works/#diagram","title":"Diagram","text":"<pre><code>User Code / Planner\n     \u2502\n     \u25bc\n Register Tools  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n (decorators/templates/YAML)   \u2502\n     \u2502                      \u2502\n     \u25bc                      \u2502\n Discover Catalog \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n (search/semantic/browse)      \u2502\n     \u2502                      \u2502\n     \u25bc                      \u2502\n Parallel Dispatch (semaphore, limits, idempotency)\n     \u2502                      \u2502\n     \u251c\u2500\u25ba Tool/Agent 1       \u2502\n     \u251c\u2500\u25ba Tool/Agent 2       \u2502\n     \u2514\u2500\u25ba Tool/Agent N       \u2502\n     \u2502                      \u2502\n     \u25bc                      \u2502\n Aggregate (vote/rank/best/collect)\n     \u2502                      \u2502\n     \u25bc                      \u2502\n Cache + Metrics + Safety (PII, secrets redactor, sandbox)\n     \u2502\n     \u25bc\n Results\n</code></pre>"},{"location":"product/how-it-works/#parallel-dispatch","title":"Parallel Dispatch","text":"<ul> <li>Concurrency control via semaphore (<code>max_concurrent</code>)</li> <li>Resource limits: cost caps, total agents, duration, failure rate</li> <li>Idempotency: cache identical requests for instant reuse</li> <li>Safety: template sanitization, PII filter</li> </ul>"},{"location":"product/how-it-works/#sandboxed-execution","title":"Sandboxed Execution","text":"<ul> <li>Restricted builtins and forbidden modules</li> <li>Timeout enforcement; captured output</li> </ul>"},{"location":"product/how-it-works/#caching","title":"Caching","text":"<ul> <li>Redis + file fallback</li> <li>TTL per layer; graceful circuit breaker on outages</li> </ul> <p>See: - Tutorial: Parallel Agents - Tutorial: Caching Deep Dive - Tutorial: Sandbox Execution</p>"},{"location":"product/overview/","title":"ToolWeaver: Secure Tool Orchestration for AI","text":""},{"location":"product/overview/#simple-explanation","title":"Simple Explanation","text":"<p>Imagine two teammates: - Smart Planner (expensive): figures out the plan - Fast Worker (efficient): executes the steps safely</p> <p>ToolWeaver helps the Planner find the right tools, then runs many small, cheap steps in parallel with safety rails. You get smart planning with fast, low-cost execution.</p>"},{"location":"product/overview/#technical-explanation","title":"Technical Explanation","text":"<p>Two-model architecture: large models (GPT-4o/Claude) plan once; small models/tools (Phi-3/Llama, APIs) execute many cheap steps. ToolWeaver provides a registry, search, parallel dispatcher, caching, and sandboxing so complex workflows run safely and predictably.</p>"},{"location":"product/overview/#the-problem","title":"The Problem","text":"<p>Integrating many tools and models into real workflows is hard: - Parallel fan-out without runaway cost or failures - Consistent schemas and discovery across heterogeneous tools - Safe execution (no secrets leakage, no dangerous code paths) - Performance (caching, idempotency) and observability</p>"},{"location":"product/overview/#the-solution","title":"The Solution","text":"<p>ToolWeaver is a package-first library to register, discover, and run tools and agents with built-in guardrails: - Secure fan-out: parallel dispatch with concurrency, cost, duration, and failure-rate limits - Safe execution: template sanitization, PII redaction, secrets-safe logging, sandboxed code - Performance: dual-layer caching (Redis + file) and idempotency for instant retries - Useful outputs: aggregation (majority vote, rank by metric, best result)</p>"},{"location":"product/overview/#why-it-matters","title":"Why It Matters","text":"<ul> <li>Ship faster: remove boilerplate for limits, logging, caching</li> <li>Scale safely: guardrails prevent cost bombs and unstable fan-outs</li> <li>Stay flexible: decorators, templates, or YAML\u2014mix and match</li> </ul>"},{"location":"product/overview/#quickstart","title":"Quickstart","text":"<ul> <li>Install and run a sample in minutes: Get Started / Quickstart</li> <li>See parallel dispatch: Tutorial / Parallel Agents</li> </ul>"},{"location":"product/overview/#package-extras-whatwhenwhy","title":"Package Extras (what/when/why)","text":"<ul> <li>redis: distributed cache. Use when you need shared caching; faster than file cache.</li> <li>vector: Qdrant + client deps. Use for semantic tool search at scale.</li> <li>monitoring: Prometheus/OTLP/Grafana deps. Use for production observability.</li> <li>all: everything above. Use for one-shot setup.</li> </ul> <p>See install matrix: Get Started / Installation</p>"},{"location":"product/overview/#learn-more","title":"Learn More","text":"<ul> <li>Concepts overview: Concepts / Overview</li> <li>Public API: Reference / Python API</li> <li>Samples: Samples Index</li> </ul>"},{"location":"product/performance/","title":"Performance &amp; Cost","text":""},{"location":"product/performance/#caching-strategy","title":"Caching strategy","text":"<ul> <li>Dual-layer: Redis + file fallback</li> <li>TTL per data type (catalog, search, embeddings, idempotency)</li> <li>Circuit breaker to handle Redis outages gracefully</li> </ul>"},{"location":"product/performance/#idempotency","title":"Idempotency","text":"<ul> <li>Automatic deduplication of identical requests</li> <li>Dramatic speedups for retries (instant hits)</li> </ul>"},{"location":"product/performance/#demonstrations","title":"Demonstrations","text":"<ul> <li>Parallel agents speedup (1.7x for 50 items)</li> <li>Caching deep dive with TTL and fallback</li> </ul> <p>See: - Tutorial: Caching Deep Dive - Tutorial: Parallel Agents</p>"},{"location":"product/project-overview/","title":"Project Overview","text":""},{"location":"product/project-overview/#simple-explanation","title":"Simple Explanation","text":"<p>Two teammates: - Smart Planner (expensive) figures out the plan - Fast Worker (efficient) executes safe, small steps</p> <p>ToolWeaver helps the Planner find the right tools and runs many cheap steps in parallel with guardrails. Result: smart planning with fast, low-cost execution.</p>"},{"location":"product/project-overview/#technical-explanation","title":"Technical Explanation","text":"<p>Large model plans once (GPT-4o/Claude). Small models and tools (Phi-3/Llama, APIs, sandboxed code) execute many steps. ToolWeaver provides: - Registry &amp; discovery (decorators/templates/YAML + hybrid search) - Parallel dispatcher with limits (cost, time, failures, concurrency) - Sandboxed execution (restricted builtins; timeouts) - Multi-layer caching &amp; idempotency - Observability (metrics/logging)</p>"},{"location":"product/project-overview/#architecture-at-a-glance","title":"Architecture at a Glance","text":"<pre><code>Natural Language \u2192 Large Model (Planning) \u2192 Tool Search \u2192 Workflow Execution\n                   1 call           Narrow K tools      Parallel nodes\n                            \u2193\n     MCP Workers   Function Calls   Sandboxed Code\n            \u2193            \u2193                \u2193\n     Small Models (Phi-3/Llama) \u2014 many cheap calls\n</code></pre>"},{"location":"product/project-overview/#why-it-matters","title":"Why It Matters","text":"<ul> <li>Ship faster: remove boilerplate for limits, logging, caching</li> <li>Scale safely: guardrails prevent runaway cost/fan-out</li> <li>Stay flexible: decorators, templates, or YAML</li> </ul>"},{"location":"product/project-overview/#quickstart","title":"Quickstart","text":"<ul> <li>Install: <code>pip install toolweaver</code></li> <li>Define a tool and run a parallel demo: see Get Started / Quickstart</li> </ul>"},{"location":"product/project-overview/#package-extras-whatwhenwhy","title":"Package Extras (what/when/why)","text":"<ul> <li><code>redis</code>: distributed cache \u2014 shared, faster than file cache</li> <li><code>vector</code>: Qdrant + client \u2014 semantic tool search at scale</li> <li><code>monitoring</code>: Prometheus/OTLP/Grafana \u2014 production observability</li> <li><code>all</code>: everything above \u2014 one-shot setup</li> </ul> <p>See details: Get Started / Installation</p>"},{"location":"product/security/","title":"Security &amp; Safety","text":""},{"location":"product/security/#simple-explanation","title":"Simple Explanation","text":"<p>Run many small steps safely: secrets never leak in logs, dangerous code is blocked, and we enforce time and resource limits.</p>"},{"location":"product/security/#technical-explanation","title":"Technical Explanation","text":"<p>Security combines template sanitization, secrets/PII redaction, sandboxed code execution (restricted builtins, timeouts, memory/FD limits, workspace path filters), and operational guardrails (cost/concurrency/rate limits, idempotency). See the concise threat model below.</p>"},{"location":"product/security/#built-in-protections","title":"Built-in protections","text":"<ul> <li>Secrets redaction: prevents credentials in logs (installed automatically)</li> <li>PII filtering: sanitize templates to avoid leakage</li> <li>Template sanitization: block dangerous tokens/patterns</li> <li>Sandboxed execution: restricted builtins/modules, timeouts</li> </ul>"},{"location":"product/security/#threat-model-concise","title":"Threat model (concise)","text":"<ul> <li>Trust: code/config from trusted operators; LLM providers trusted; user inputs untrusted; external APIs/vector/cache stores treated as potentially hostile.</li> <li>Code execution risks: mitigated by sandbox (no network, restricted builtins, timeouts, memory/FD limits, workspace path filter).</li> <li>Resource exhaustion: timeouts, memory/FD limits, rate limits, quotas on workspace/files.</li> <li>Information disclosure: env filtering, workspace isolation, redaction in logs/outputs.</li> <li>Privilege/supply chain: role checks on sensitive ops, pinned deps; prefer managed secrets (Vault/Key Vault) and signed skills where available.</li> </ul> <p>Operational checklist - Use Managed Identity/Key Vault (avoid plain API keys in prod). - Enable metrics/logging with redaction; alert on error/timeout spikes. - Set cost/concurrency/rate limits for fan-out workloads. - Rotate secrets regularly; restrict network egress for sandboxes where possible.</p>"},{"location":"product/security/#operational-guardrails","title":"Operational guardrails","text":"<ul> <li>Cost caps and concurrency limits</li> <li>Failure-rate thresholds and total duration limits</li> <li>Idempotency cache: avoid duplicate execution</li> </ul> <p>See: - Logging Helpers - Sandbox Execution - Parallel Agents</p>"},{"location":"product/use-cases/","title":"Use Cases","text":""},{"location":"product/use-cases/#batch-processing","title":"Batch processing","text":"<p>Process many items concurrently with safe limits. - Demo: Parallel Agents</p>"},{"location":"product/use-cases/#ensemble-voting","title":"Ensemble voting","text":"<p>Run multiple models and select consensus/best. - Demo: Parallel Agents</p>"},{"location":"product/use-cases/#tool-discovery-at-scale","title":"Tool discovery at scale","text":"<p>Find the right tools across domains and keywords. - Demo: GitHub Operations</p>"},{"location":"product/use-cases/#cost-optimization","title":"Cost optimization","text":"<p>Cache discovery and idempotent runs; avoid repeats. - Demo: Caching Deep Dive</p>"},{"location":"product/use-cases/#safe-code-execution","title":"Safe code execution","text":"<p>Run custom code with sandboxed builtins and timeouts. - Demo: Sandbox Execution</p>"},{"location":"product/use-cases/#rapid-tool-integration","title":"Rapid tool integration","text":"<p>Register new tools via decorators, templates, or YAML. - Demo: Adding Tools (3 Ways)</p>"},{"location":"product/why-toolweaver/","title":"Why ToolWeaver","text":""},{"location":"product/why-toolweaver/#designed-for-production","title":"Designed for production","text":"<ul> <li>Package-first: pip install and use inside your apps\u2014no heavy framework</li> <li>Guardrails built in: cost caps, concurrency, failure thresholds, timeouts</li> <li>Safe by default: secrets redactor, PII filtering, template sanitization, sandbox</li> </ul>"},{"location":"product/why-toolweaver/#developer-experience","title":"Developer experience","text":"<ul> <li>Three ways to register tools: decorators, templates, YAML</li> <li>Discovery/search: domain, keywords, semantic search</li> <li>Aggregation patterns: majority vote, rank by metric, best result, collect-all</li> </ul>"},{"location":"product/why-toolweaver/#performance","title":"Performance","text":"<ul> <li>Dual-layer cache with file fallback</li> <li>Idempotency caching for instant replays</li> <li>Demonstrated speedups in tutorials (1.7x for batch parallelism)</li> </ul>"},{"location":"product/why-toolweaver/#fit","title":"Fit","text":"<ul> <li>Use with planners or call programmatically</li> <li>Expose tools via REST quickly (FastAPI adapter)</li> <li>Extend via plugins and share via skills</li> </ul> <p>See: - Product Overview - Tutorials - Public API</p>"},{"location":"reference/","title":"Reference","text":"<ul> <li>Public API</li> <li>Python API</li> <li>Configuration</li> <li>CLI</li> <li>Deep Dives</li> <li>REST API</li> </ul>"},{"location":"reference/api/","title":"Public API","text":"<p>This page orients you to all ToolWeaver interfaces.</p> <p>Choose your path - Python API (how-to guides by topic): Python Public API Overview - Python exports (fast lookup): API Exports Index - REST API (HTTP endpoints): REST API Overview - Runnable examples: Samples index</p> <p>Python exports map (by group) - Decorators: <code>tool</code>, <code>mcp_tool</code>, <code>a2a_agent</code> - Templates: <code>BaseTemplate</code>, <code>FunctionToolTemplate</code>, <code>MCPToolTemplate</code>, <code>CodeExecToolTemplate</code>, <code>AgentTemplate</code>, <code>register_template</code> - YAML loaders: <code>load_tools_from_yaml</code>, <code>load_tools_from_directory</code>, <code>YAMLLoaderError</code>, <code>YAMLValidationError</code>, <code>WorkerResolutionError</code> - Skills: <code>save_tool_as_skill</code>, <code>load_tool_from_skill</code>, <code>get_tool_skill</code>, <code>sync_tool_with_skill</code>, <code>get_skill_backed_tools</code> - Discovery: <code>get_available_tools</code>, <code>search_tools</code>, <code>get_tool_info</code>, <code>list_tools_by_domain</code>, <code>semantic_search_tools</code>, <code>browse_tools</code> - Plugins: <code>register_plugin</code>, <code>unregister_plugin</code>, <code>get_plugin</code>, <code>list_plugins</code>, <code>discover_plugins</code> - Configuration: <code>get_config</code>, <code>reset_config</code>, <code>validate_config</code> - Logging: <code>get_logger</code>, <code>set_log_level</code>, <code>enable_debug_mode</code> - Agent-to-agent client: <code>AgentCapability</code>, <code>AgentDelegationRequest</code>, <code>AgentDelegationResponse</code>, <code>A2AClient</code></p>"},{"location":"reference/cli/","title":"CLI Reference","text":"<p>Browse tools from the command line.</p> <pre><code>python -m orchestrator.cli list\npython -m orchestrator.cli search --query \"receipt\"\npython -m orchestrator.cli info --tool receipt_ocr\n</code></pre> <p>Commands: - <code>list</code>: List all available tools. - <code>search --query &lt;text&gt;</code>: Search tools. - <code>info --tool &lt;name&gt;</code>: Show details for a tool. - <code>browse --query &lt;text&gt;</code>: Progressive detail browsing.</p>"},{"location":"reference/config/","title":"Configuration","text":"<p>Use <code>get_config()</code> to read runtime settings and environment overrides.</p> <p>Common env vars: - <code>REDIS_URL</code>: Redis connection for cache (optional; file cache is fallback). - <code>TOOLWEAVER_CACHE_PATH</code>: Override local cache directory. - Provider credentials: set per tool (e.g., Azure/OpenAI keys) as needed.</p> <p>Validate config:</p> <pre><code>from orchestrator import validate_config\nprint(validate_config())\n</code></pre> <p>Reset cached config:</p> <pre><code>from orchestrator import reset_config\nreset_config()\n</code></pre>"},{"location":"reference/api-python/","title":"Python API","text":"<ul> <li>Overview</li> <li>Exports Index</li> <li>Decorators</li> <li>Templates</li> <li>YAML Loaders</li> <li>Skill Bridge</li> <li>Discovery</li> <li>Plugins</li> <li>Configuration</li> <li>Logging</li> <li>A2A Client</li> <li>Version &amp; Security</li> </ul>"},{"location":"reference/api-python/a2a-client/","title":"Agent-to-Agent Client (A2A)","text":"<p>Why: Delegate work to other agents securely and compose agent networks. Jump to symbols: API Exports Index</p> <p>Exports: <code>AgentCapability</code>, <code>AgentDelegationRequest</code>, <code>AgentDelegationResponse</code>, <code>A2AClient</code></p>"},{"location":"reference/api-python/a2a-client/#concepts","title":"Concepts","text":"<ul> <li>Capability: a named function an agent can perform (e.g., <code>classifier</code>)</li> <li>Delegation request: payload and desired capability</li> <li>Response: result and metadata</li> </ul>"},{"location":"reference/api-python/a2a-client/#example","title":"Example","text":"<p>What: Delegate a request to another agent via <code>A2AClient</code>. When: Compose multi-agent workflows or offload specialized tasks.</p> <pre><code>from orchestrator import AgentCapability, AgentDelegationRequest, A2AClient\n\nclient = A2AClient()\ncap = AgentCapability(name=\"classifier\", version=\"1.0\")\nreq = AgentDelegationRequest(capability=cap, payload={\"text\": \"Buy laptop\"})\nresp = await client.delegate(req)\nprint(resp)\n</code></pre> <p>Related: - Tutorial: Parallel Agents</p>"},{"location":"reference/api-python/configuration/","title":"Configuration","text":"<p>Why: Control runtime behavior via environment variables and defaults. Jump to symbols: API Exports Index</p> <p>Exports: <code>get_config</code>, <code>reset_config</code>, <code>validate_config</code></p>"},{"location":"reference/api-python/configuration/#typical-fields","title":"Typical fields","text":"<ul> <li>Cache path: local cache directory</li> <li>Redis URL: distributed cache endpoint (optional)</li> <li>Skill path: location for skill packages</li> <li>Logging level: default log verbosity</li> </ul>"},{"location":"reference/api-python/configuration/#read-config","title":"Read config","text":"<p>What: Fetch current runtime configuration. When: Inspect defaults or confirm environment overrides.</p> <pre><code>from orchestrator import get_config\ncfg = get_config()\nprint(cfg)\n</code></pre>"},{"location":"reference/api-python/configuration/#validate","title":"Validate","text":"<p>What: Validate configuration values and surface warnings/errors. When: CI checks or startup validation.</p> <pre><code>from orchestrator import validate_config\nprint(validate_config())\n</code></pre>"},{"location":"reference/api-python/configuration/#reset","title":"Reset","text":"<p>What: Clear cached configuration state. When: After changing env vars or during tests to ensure fresh loads.</p> <pre><code>from orchestrator import reset_config\nreset_config()\n</code></pre> <p>Related: - Reference: Configuration</p>"},{"location":"reference/api-python/decorators/","title":"Decorators","text":"<p>Why: Fastest way to convert Python functions into ToolWeaver tools. Decorators infer parameter schemas from type hints and register callable endpoints for planners, APIs, and CLI. Jump to symbols: API Exports Index</p> <p>Exports: <code>tool</code>, <code>mcp_tool</code>, <code>a2a_agent</code></p>"},{"location":"reference/api-python/decorators/#mcp_tool","title":"<code>mcp_tool()</code>","text":"<ul> <li>What: Register a tool following MCP-style semantics with structured parameters and async execution.</li> <li>When: Use for tools you want discoverable and callable across adapters (FastAPI, CLI, planners).</li> <li>How: Decorate an <code>async</code> function with type hints; provide metadata like <code>domain</code>, <code>description</code>.</li> </ul> <p>Parameters (common): - <code>domain</code>: short namespace grouping (e.g., \"github\", \"finance\") - <code>description</code>: human-friendly description - Optional metadata via keyword args depending on implementation</p> <p>Returns: A callable tool object; the decorated function is registered in the catalog.</p> <p>Example:</p> <pre><code>from orchestrator import mcp_tool, search_tools\n\n@mcp_tool(domain=\"github\", description=\"List repositories\")\nasync def list_repositories(org: str, limit: int = 10) -&gt; dict:\n    return {\"repositories\": [\"repo-a\", \"repo-b\"]}\n\nprint([t.name for t in search_tools(domain=\"github\")])\n</code></pre> <p>Pitfalls: - Ensure function is <code>async</code> for non-blocking execution. - Use precise type hints for reliable schema extraction.</p>"},{"location":"reference/api-python/decorators/#tool","title":"<code>tool()</code>","text":"<ul> <li>What: Generic decorator for simple tool registration without MCP extras.</li> <li>When: Use for lightweight utilities or internal helpers; still discoverable.</li> <li>How: Decorate a function and provide minimal metadata.</li> </ul> <p>Example:</p> <pre><code>from orchestrator import tool\n\n@tool(domain=\"demo\")\nasync def echo(message: str) -&gt; dict:\n    return {\"echo\": message}\n</code></pre>"},{"location":"reference/api-python/decorators/#a2a_agent","title":"<code>a2a_agent()</code>","text":"<ul> <li>What: Wrap an agent function to be delegatable via the A2A client.</li> <li>When: Use for higher-level evaluators/classifiers that other agents call.</li> <li>How: Decorate an async function; give it a stable <code>name</code> and optional version.</li> </ul> <p>Example:</p> <pre><code>from orchestrator import a2a_agent\n\n@a2a_agent(name=\"classifier\", version=\"1.0\")\nasync def classify(text: str) -&gt; dict:\n    return {\"label\": \"electronics\"}\n</code></pre> <p>Related: - Samples: samples/23-adding-new-tools/three_ways.py - Concepts: Overview</p>"},{"location":"reference/api-python/discovery/","title":"Discovery &amp; Search","text":"<p>Why: Find and browse tools programmatically for planners, APIs, and UIs. Jump to symbols: API Exports Index</p> <p>Exports: <code>get_available_tools</code>, <code>search_tools</code>, <code>get_tool_info</code>, <code>list_tools_by_domain</code>, <code>semantic_search_tools</code>, <code>browse_tools</code></p>"},{"location":"reference/api-python/discovery/#get_available_tools","title":"<code>get_available_tools()</code>","text":"<p>What: Return all registered tools. When: Bootstrap catalogs for planners or adapters.</p> <pre><code>from orchestrator import get_available_tools\ntools = get_available_tools()\nprint(\"Total tools:\", len(tools))\n</code></pre>"},{"location":"reference/api-python/discovery/#search_tools","title":"<code>search_tools(...)</code>","text":"<p>What: Filter tools by domain/keywords/provider. When: User-driven discovery or planner narrowing.</p> <pre><code>from orchestrator import search_tools\n\n# Search by domain (no query required)\nfinance_tools = search_tools(query=\"\", domain=\"finance\")\nprint([t.name for t in finance_tools])\n\n# Search with query + domain filter\ntools = search_tools(query=\"send message\", domain=\"comms\")\n</code></pre>"},{"location":"reference/api-python/discovery/#get_tool_infoname","title":"<code>get_tool_info(name)</code>","text":"<p>What: Detailed definition for a tool by name. When: Render schemas in UIs or validate parameters.</p> <pre><code>from orchestrator import get_tool_info\nprint(get_tool_info(\"receipt_ocr\"))\n</code></pre>"},{"location":"reference/api-python/discovery/#list_tools_by_domaindomain","title":"<code>list_tools_by_domain(domain)</code>","text":"<p>What: List tools within a given domain. When: Build domain-focused menus or filters.</p> <pre><code>from orchestrator import list_tools_by_domain\nprint(list_tools_by_domain(\"finance\"))\n</code></pre>"},{"location":"reference/api-python/discovery/#semantic_search_toolsquery","title":"<code>semantic_search_tools(query)</code>","text":"<p>What: Semantic matching against tool descriptions. When: Natural language discovery flows.</p> <pre><code>from orchestrator import semantic_search_tools\nprint(semantic_search_tools(query=\"process receipts\"))\n</code></pre>"},{"location":"reference/api-python/discovery/#browse_toolsquery","title":"<code>browse_tools(query)</code>","text":"<p>What: Progressive detail browsing for CLI/UX. When: Guided exploration flows.</p> <pre><code>from orchestrator import browse_tools\nprint(browse_tools(query=\"github\"))\n</code></pre> <p>Related:</p>"},{"location":"reference/api-python/logging/","title":"Logging Helpers","text":"<p>Why: Enable observability and safe logging. Jump to symbols: API Exports Index</p> <p>Exports: <code>get_logger</code>, <code>set_log_level</code>, <code>enable_debug_mode</code></p>"},{"location":"reference/api-python/logging/#safe-logging","title":"Safe logging","text":"<ul> <li><code>enable_debug_mode()</code> installs a secrets redactor on the root logger to prevent token leakage.</li> <li>Use <code>set_log_level(\"INFO\")</code> to control verbosity globally.</li> </ul>"},{"location":"reference/api-python/logging/#usage","title":"Usage","text":"<p>What: Configure logging with safe defaults. When: Set module logger, adjust verbosity, and install redaction before emitting logs.</p> <pre><code>from orchestrator import get_logger, set_log_level, enable_debug_mode\n\nlogger = get_logger(__name__)\nset_log_level(\"INFO\")\n\nenable_debug_mode()\nlogger.info(\"hello\")\n</code></pre> <p>Related: - Concepts: Overview</p>"},{"location":"reference/api-python/overview/","title":"Python Public API Overview","text":"<p>ToolWeaver exposes a clean, package-first API via <code>orchestrator</code>. This section documents grouped capabilities with why/what/how and examples.</p>"},{"location":"reference/api-python/overview/#simple-explanation","title":"Simple Explanation","text":"<p>The Python API gives you clear building blocks to register, discover, and run tools. Most teams start with decorators to turn functions into tools; use templates when you need full control; use YAML loaders to configure tools without code.</p>"},{"location":"reference/api-python/overview/#technical-explanation","title":"Technical Explanation","text":"<p>The public surface lives under <code>orchestrator.*</code> and is organized by domains: registration (decorators, templates, YAML), catalog (discovery/search), runtime (configuration, logging), extension (plugins, skills), and interop (A2A). Use the Exports Index for a flat symbol lookup and the group pages for patterns and examples.</p> <p>How to navigate: - Start with these guides for concepts and examples: Decorators, Templates, YAML loaders, Skill bridge, Discovery, Plugins, Configuration, Logging, A2A client, Version &amp; security. - Need a symbol fast? Jump to the flat API Exports Index. - Calling over HTTP instead of Python? See the REST API Overview. - Prefer runnable code? Browse the Samples index.</p> <p>Groups: - Decorators: register tools quickly with type-hinted functions - Templates: full-control classes for tool definitions - YAML loaders: config-driven registration - Skill bridge: save/load tools as reusable skills - Discovery/search: list, search, browse tools - Plugins: extend ToolWeaver - Configuration: manage runtime settings - Logging: observability helpers - Agent-to-agent client (A2A): delegate work to other agents - Version &amp; security: package version and auto secrets redaction</p> <p>Start with the quick summary: Public API, then dive into groups below.</p>"},{"location":"reference/api-python/plugins/","title":"Plugins","text":"<p>Why: Extend ToolWeaver with third-party integrations, additional discovery sources, or custom behaviors. Jump to symbols: API Exports Index</p> <p>Exports: <code>register_plugin</code>, <code>unregister_plugin</code>, <code>get_plugin</code>, <code>list_plugins</code>, <code>discover_plugins</code></p>"},{"location":"reference/api-python/plugins/#lifecycle","title":"Lifecycle","text":"<ul> <li>Register: <code>register_plugin(name, instance)</code></li> <li>Discover: <code>discover_plugins()</code> (optional scanning)</li> <li>Get: <code>get_plugin(name)</code></li> <li>List: <code>list_plugins()</code></li> <li>Unregister: <code>unregister_plugin(name)</code></li> </ul>"},{"location":"reference/api-python/plugins/#register-a-plugin","title":"Register a plugin","text":"<p>What: Add a plugin instance to the registry. When: Enable a custom integration or discovery source.</p> <pre><code>from orchestrator import register_plugin\n\nclass MyPlugin:\n    def setup(self):\n        print(\"hello from plugin\")\n\nregister_plugin(\"my_plugin\", MyPlugin())\n</code></pre>"},{"location":"reference/api-python/plugins/#discover-list","title":"Discover &amp; list","text":"<p>What: Auto-scan for discoverable plugins and enumerate them. When: Bootstrap plugins without manual registration or audit what is loaded.</p> <pre><code>from orchestrator import discover_plugins, list_plugins\ndiscover_plugins()\nprint(list_plugins())\n</code></pre> <p>Related: - Concepts: Overview</p>"},{"location":"reference/api-python/skill-bridge/","title":"Skill Bridge","text":"<p>Why: Persist and share tools as reusable skills. Jump to symbols: API Exports Index</p> <p>Exports: <code>save_tool_as_skill</code>, <code>load_tool_from_skill</code>, <code>get_tool_skill</code>, <code>sync_tool_with_skill</code>, <code>get_skill_backed_tools</code></p>"},{"location":"reference/api-python/skill-bridge/#save-a-tool-as-a-skill","title":"Save a tool as a skill","text":"<p>What: Persist a registered tool into a reusable skill package. When: Promote a vetted tool for sharing across teams/environments.</p> <pre><code>from orchestrator import save_tool_as_skill, mcp_tool\n\n@mcp_tool(domain=\"demo\")\nasync def echo(message: str) -&gt; dict:\n    return {\"echo\": message}\n\nsave_tool_as_skill(\"echo\", org=\"acme\")\n</code></pre>"},{"location":"reference/api-python/skill-bridge/#load-a-skill","title":"Load a skill","text":"<p>What: Retrieve a previously saved skill-backed tool. When: Reuse approved tools without redefining code.</p> <pre><code>from orchestrator import load_tool_from_skill\ntool = load_tool_from_skill(\"echo\", org=\"acme\")\nprint(tool)\n</code></pre> <p>Links: - Concepts: Overview</p>"},{"location":"reference/api-python/templates/","title":"Template Classes &amp; Registration","text":"<p>Why: Maximum control over tool definitions, metadata, validation, and execution lifecycle. Jump to symbols: API Exports Index</p> <p>Exports: <code>BaseTemplate</code>, <code>FunctionToolTemplate</code>, <code>MCPToolTemplate</code>, <code>CodeExecToolTemplate</code>, <code>AgentTemplate</code>, <code>register_template</code></p>"},{"location":"reference/api-python/templates/#basetemplate","title":"<code>BaseTemplate</code>","text":"<ul> <li>What: Abstract base for all tool templates.</li> <li>When: Subclass to build custom behaviors beyond built-ins.</li> <li>How: Define <code>name</code>, <code>description</code>, <code>parameters</code>, and <code>run()</code>.</li> </ul>"},{"location":"reference/api-python/templates/#functiontooltemplate","title":"<code>FunctionToolTemplate</code>","text":"<ul> <li>What: Define function-style tools with explicit schema.</li> <li>When: Prefer when you need strong schema control or custom validation.</li> <li>How: Set <code>parameters</code> with <code>ToolParameter</code> entries; implement <code>run()</code>.</li> </ul> <p>Example:</p> <pre><code>from orchestrator import FunctionToolTemplate\nfrom orchestrator.shared.models import ToolParameter\n\nclass AddTool(FunctionToolTemplate):\n    name = \"add\"\n    description = \"Sum two numbers\"\n    parameters = [\n        ToolParameter(name=\"a\", type=\"number\", required=True),\n        ToolParameter(name=\"b\", type=\"number\", required=True),\n    ]\n    async def run(self, a: float, b: float) -&gt; dict:\n        return {\"sum\": a + b}\n</code></pre>"},{"location":"reference/api-python/templates/#mcptooltemplate","title":"<code>MCPToolTemplate</code>","text":"<ul> <li>What: MCP-flavored template with richer discovery metadata.</li> <li>When: Use when exposing tools to MCP-based planners/adapters.</li> </ul>"},{"location":"reference/api-python/templates/#codeexectooltemplate","title":"<code>CodeExecToolTemplate</code>","text":"<ul> <li>What: Tools that execute user-provided code with sandbox controls.</li> <li>When: Use for safe code execution tasks; pairs with sandbox features.</li> </ul>"},{"location":"reference/api-python/templates/#agenttemplate","title":"<code>AgentTemplate</code>","text":"<ul> <li>What: Define agent-style tools (evaluators, classifiers, planners).</li> <li>When: Provide consistent schema and lifecycle around agent calls.</li> </ul>"},{"location":"reference/api-python/templates/#register_template","title":"<code>register_template()</code>","text":"<ul> <li>What: Add a custom template to the registry.</li> <li>When: Make your custom template discoverable for use.</li> <li>How: Call with your class reference.</li> </ul> <pre><code>from orchestrator import register_template\nregister_template(AddTool)\n</code></pre> <p>Related: - Sample: samples/23-adding-new-tools/three_ways.py</p>"},{"location":"reference/api-python/version-security/","title":"Version &amp; Security","text":"<p>Why: Understand package version and built-in safety features. Jump to symbols: API Exports Index</p> <p>Exports: - <code>__version__</code>: package version string - Auto-installed secrets redactor: prevents credentials from appearing in logs</p>"},{"location":"reference/api-python/version-security/#usage","title":"Usage","text":"<pre><code>import orchestrator\nprint(orchestrator.__version__)\n</code></pre> <p>Security: - On import, a secrets redactor is installed on the root logger. - Combine with <code>enable_debug_mode()</code> for consistent safe logging.</p> <p>Related: - Concepts: Overview</p>"},{"location":"reference/api-python/yaml-loaders/","title":"YAML Loaders","text":"<p>Why: Configuration-driven registration for repeatable deployments and non-Python authorship. Jump to symbols: API Exports Index</p> <p>Exports: <code>load_tools_from_yaml</code>, <code>load_tools_from_directory</code>, <code>YAMLLoaderError</code>, <code>YAMLValidationError</code>, <code>WorkerResolutionError</code></p>"},{"location":"reference/api-python/yaml-loaders/#schema-example","title":"Schema (example)","text":"<pre><code>name: add\ndescription: Sum two numbers\nprovider: python\nparameters:\n  - name: a\n    type: number\n    required: true\n  - name: b\n    type: number\n    required: true\nmetadata:\n  domain: finance\n</code></pre> <p>Load a single file: What: Register one YAML-defined tool. When: You have a single definition to load or test.</p> <pre><code>from orchestrator import load_tools_from_yaml\nload_tools_from_yaml(\"add.yaml\")\n</code></pre> <p>Load a directory: What: Bulk-load multiple YAML tool definitions. When: Deploy or refresh a set of tools from config.</p> <pre><code>from orchestrator import load_tools_from_directory\nload_tools_from_directory(\"./tools_yaml\")\n</code></pre> <p>Errors: - <code>YAMLLoaderError</code>: General load failure (file not found, parse error) - <code>YAMLValidationError</code>: Schema invalid (missing fields, wrong types) - <code>WorkerResolutionError</code>: Referenced worker/tool backend cannot be resolved</p> <p>Related: - Sample: samples/23-adding-new-tools/three_ways.py</p>"},{"location":"reference/api-python/exports/","title":"API Exports Index","text":"<p>Deep links for ultra-granular browsing, with brief descriptions of what, when, and how. For HTTP endpoints, use the REST API Overview.</p>"},{"location":"reference/api-python/exports/#decorators","title":"Decorators","text":"<ul> <li>Why: Fastest way to convert Python functions into discoverable, callable tools/agents.</li> <li>What: Schema inferred from type hints; registered into the catalog for planners, REST, and CLI.</li> <li>When: Use <code>mcp_tool</code> for public tools, <code>tool</code> for lightweight utilities, <code>a2a_agent</code> for delegatable agents.</li> <li>tool \u2014 Register a generic tool from a Python function.</li> <li>mcp_tool \u2014 Register an MCP-style tool with structured parameters for discovery.</li> <li>a2a_agent \u2014 Wrap an agent function to delegate via the A2A client.</li> </ul>"},{"location":"reference/api-python/exports/#decorators-overview","title":"Decorators Overview","text":""},{"location":"reference/api-python/exports/#templates","title":"Templates","text":"<ul> <li>Why: Maximum control over tool definitions, parameters, validation, and lifecycle.</li> <li>What: Class-based tools with explicit schemas and custom behaviors.</li> <li>When: Use when decorators are too limiting or for sandbox/code-exec scenarios.</li> <li>BaseTemplate \u2014 Abstract base for custom template behaviors.</li> <li>FunctionToolTemplate \u2014 Define function-style tools with explicit schemas.</li> <li>MCPToolTemplate \u2014 MCP-flavored template with richer discovery metadata.</li> <li>CodeExecToolTemplate \u2014 Execute user-provided code with sandbox controls.</li> <li>AgentTemplate \u2014 Define agent-style tools (evaluators, classifiers).</li> </ul>"},{"location":"reference/api-python/exports/#templates-overview","title":"Templates Overview","text":""},{"location":"reference/api-python/exports/#yaml-loaders","title":"YAML Loaders","text":"<ul> <li>Why: Configuration-driven registration for repeatable deployments and non-Python authors.</li> <li>What: Load single files or directories of YAML; validated schemas with clear error types.</li> <li>When: Use in DevOps pipelines or to share tools without Python code changes.</li> <li>load_tools_from_yaml \u2014 Load a single YAML tool definition.</li> <li>load_tools_from_directory \u2014 Bulk load YAML tool definitions from a directory.</li> <li>YAMLLoaderError \u2014 General loading error (IO/parse).</li> <li>YAMLValidationError \u2014 Schema validation error.</li> <li>WorkerResolutionError \u2014 Referenced backend/worker cannot be resolved.</li> </ul>"},{"location":"reference/api-python/exports/#yaml-loaders-overview","title":"YAML Loaders Overview","text":""},{"location":"reference/api-python/exports/#skill-bridge","title":"Skill Bridge","text":"<ul> <li>Why: Persist and share tools as reusable skills across teams/environments.</li> <li>What: Save, load, sync skills; list tools backed by skills.</li> <li>When: Promote approved tools to a registry for standardized reuse.</li> <li>save_tool_as_skill \u2014 Persist a tool as a reusable skill package.</li> <li>load_tool_from_skill \u2014 Load a skill-backed tool for reuse.</li> <li>get_tool_skill \u2014 Retrieve a tool\u2019s associated skill metadata.</li> <li>sync_tool_with_skill \u2014 Synchronize tool changes to its skill package.</li> <li>get_skill_backed_tools \u2014 List tools backed by skills.</li> </ul>"},{"location":"reference/api-python/exports/#skill-bridge-overview","title":"Skill Bridge Overview","text":""},{"location":"reference/api-python/exports/#discovery","title":"Discovery","text":"<ul> <li>Why: Find and browse the right tools for planners, UIs, and workflows.</li> <li>What: List all tools, keyword/domain search, semantic matching, and progressive browsing.</li> <li>When: Build catalogs, surface tools to users, or feed planners.</li> <li>get_available_tools \u2014 Return all registered tools.</li> <li>search_tools \u2014 Filter tools by domain/keywords.</li> <li>get_tool_info \u2014 Detailed definition for a tool by name.</li> <li>list_tools_by_domain \u2014 List tools within a given domain.</li> <li>semantic_search_tools \u2014 Natural language matching against tool descriptions.</li> <li>browse_tools \u2014 Progressive detail browsing suitable for CLI/UX.</li> </ul>"},{"location":"reference/api-python/exports/#discovery-overview","title":"Discovery Overview","text":""},{"location":"reference/api-python/exports/#plugins","title":"Plugins","text":"<ul> <li>Why: Extend ToolWeaver with new discovery sources, integrations, and custom behaviors.</li> <li>What: Register, list, get, unregister, and auto-discover plugins.</li> <li>When: Add bespoke capabilities without modifying core.</li> <li>register_plugin \u2014 Register a plugin instance.</li> <li>unregister_plugin \u2014 Remove a plugin by name.</li> <li>get_plugin \u2014 Retrieve a plugin instance.</li> <li>list_plugins \u2014 List all registered plugins.</li> <li>discover_plugins \u2014 Scan and auto-register discoverable plugins.</li> </ul>"},{"location":"reference/api-python/exports/#plugins-overview","title":"Plugins Overview","text":""},{"location":"reference/api-python/exports/#configuration","title":"Configuration","text":"<ul> <li>Why: Control runtime behavior via environment variables and defaults.</li> <li>What: Read, reset, and validate configuration; typical fields include cache path, Redis URL, skill path, and logging.</li> <li>When: Setup environment, troubleshoot issues, and standardize deployments.</li> <li>get_config \u2014 Read current runtime configuration.</li> <li>reset_config \u2014 Reset cached configuration state.</li> <li>validate_config \u2014 Validate configuration and return warnings/errors.</li> </ul>"},{"location":"reference/api-python/exports/#configuration-overview","title":"Configuration Overview","text":""},{"location":"reference/api-python/exports/#logging","title":"Logging","text":"<ul> <li>Why: Provide observability with safety (secrets never leak into logs).</li> <li>What: Module-specific loggers, global log level, and a secrets redactor installed via debug mode.</li> <li>When: Standardize logging across apps and CI while protecting credentials.</li> <li>get_logger \u2014 Get a module-specific logger with safe defaults.</li> <li>set_log_level \u2014 Set global log level.</li> <li>enable_debug_mode \u2014 Install secrets redactor and enable safe logging.</li> </ul>"},{"location":"reference/api-python/exports/#logging-overview","title":"Logging Overview","text":""},{"location":"reference/api-python/exports/#a2a-client","title":"A2A Client","text":"<ul> <li>Why: Delegate work to other agents and compose agent networks.</li> <li>What: Capabilities, delegation requests/responses, and <code>A2AClient</code> for execution.</li> <li>When: Orchestrate multi-agent workflows and federated capabilities.</li> <li>AgentCapability \u2014 Describe a capability an agent provides.</li> <li>AgentDelegationRequest \u2014 Request payload to delegate to an agent.</li> <li>AgentDelegationResponse \u2014 Response payload from delegated agent.</li> <li>A2AClient \u2014 Client to delegate requests to agents.</li> </ul>"},{"location":"reference/api-python/exports/#a2a-client-overview","title":"A2A Client Overview","text":""},{"location":"reference/api-python/exports/#version-security","title":"Version &amp; Security","text":"<ul> <li>Why: Track package version and leverage built-in safety features.</li> <li>What: <code>__version__</code> string and an auto-installed secrets redactor on import.</li> <li>When: Display version in UIs/logs and ensure safe logging defaults.</li> <li>version \u2014 Package version string.</li> <li>secrets redactor \u2014 Auto-installed redactor to prevent secrets appearing in logs.</li> </ul>"},{"location":"reference/api-python/exports/#version-security-overview","title":"Version &amp; Security Overview","text":""},{"location":"reference/api-python/exports/a2a-client/A2AClient/","title":"<code>A2AClient</code>","text":"<ul> <li>What: Client to delegate requests to agents.</li> <li>When: Compose agent networks.</li> <li>Example:</li> </ul> <pre><code>from orchestrator import A2AClient, AgentCapability, AgentDelegationRequest\nclient = A2AClient()\ncap = AgentCapability(name=\"classifier\", version=\"1.0\")\nreq = AgentDelegationRequest(capability=cap, payload={\"text\": \"Buy laptop\"})\nresp = await client.delegate(req)\nprint(resp)\n</code></pre> <ul> <li>Links: A2A Client</li> </ul>"},{"location":"reference/api-python/exports/a2a-client/AgentCapability/","title":"<code>AgentCapability</code>","text":"<ul> <li>What: Describe a capability an agent provides.</li> <li>When: Build delegation requests.</li> <li>Example:</li> </ul> <pre><code>from orchestrator import AgentCapability\ncap = AgentCapability(name=\"classifier\", version=\"1.0\")\n</code></pre> <ul> <li>Links: A2A Client</li> </ul>"},{"location":"reference/api-python/exports/a2a-client/AgentDelegationRequest/","title":"<code>AgentDelegationRequest</code>","text":"<ul> <li>What: Request payload to delegate to an agent.</li> <li>When: Invoke capabilities with inputs.</li> <li>Example:</li> </ul> <pre><code>from orchestrator import AgentDelegationRequest, AgentCapability\ncap = AgentCapability(name=\"classifier\", version=\"1.0\")\nreq = AgentDelegationRequest(capability=cap, payload={\"text\": \"Buy laptop\"})\n</code></pre> <ul> <li>Links: A2A Client</li> </ul>"},{"location":"reference/api-python/exports/a2a-client/AgentDelegationResponse/","title":"<code>AgentDelegationResponse</code>","text":"<ul> <li>What: Response payload from delegated agent.</li> <li>When: Inspect results and metadata.</li> <li>Links: A2A Client</li> </ul>"},{"location":"reference/api-python/exports/configuration/get_config/","title":"<code>get_config</code>","text":"<ul> <li>What: Read runtime configuration.</li> <li>When: Inspect settings (cache path, redis, logging).</li> <li>Example:</li> </ul> <pre><code>from orchestrator import get_config\nprint(get_config())\n</code></pre> <ul> <li>Links: Configuration</li> </ul>"},{"location":"reference/api-python/exports/configuration/reset_config/","title":"<code>reset_config</code>","text":"<ul> <li>What: Reset cached configuration state.</li> <li>When: After changing env vars.</li> <li>Example:</li> </ul> <pre><code>from orchestrator import reset_config\nreset_config()\n</code></pre> <ul> <li>Links: Configuration</li> </ul>"},{"location":"reference/api-python/exports/configuration/validate_config/","title":"<code>validate_config</code>","text":"<ul> <li>What: Validate current configuration; returns list of warnings/errors.</li> <li>When: Debug environment issues.</li> <li>Example:</li> </ul> <pre><code>from orchestrator import validate_config\nprint(validate_config())\n</code></pre> <ul> <li>Links: Configuration</li> </ul>"},{"location":"reference/api-python/exports/decorators/a2a_agent/","title":"<code>a2a_agent</code>","text":"<ul> <li>What: Wrap an agent for delegation via A2A client.</li> <li>When: Higher-level classifiers/evaluators callable by other agents.</li> <li>How:</li> </ul> <pre><code>from orchestrator import a2a_agent\n\n@a2a_agent(name=\"classifier\", version=\"1.0\")\nasync def classify(text: str) -&gt; dict:\n    return {\"label\": \"electronics\"}\n</code></pre> <ul> <li>Returns: Registered agent callable.</li> <li>Links: A2A Client, Parallel Agents</li> </ul>"},{"location":"reference/api-python/exports/decorators/mcp_tool/","title":"<code>mcp_tool</code>","text":"<ul> <li>What: Register an MCP-style tool with structured parameters.</li> <li>When: Tools discoverable across adapters and planners.</li> <li>How:</li> </ul> <pre><code>from orchestrator import mcp_tool\n\n@mcp_tool(domain=\"github\", description=\"List repositories\")\nasync def list_repositories(org: str, limit: int = 10) -&gt; dict:\n    return {\"repositories\": [\"repo-a\", \"repo-b\"]}\n</code></pre> <ul> <li>Returns: Registered tool callable.</li> <li>Pitfalls: Function must be <code>async</code>; use precise type hints.</li> <li>Links: Decorators, REST API</li> </ul>"},{"location":"reference/api-python/exports/decorators/tool/","title":"<code>tool</code>","text":"<ul> <li>What: Register a generic tool from a Python function.</li> <li>When: Quick utilities and internal helpers.</li> <li>How:</li> </ul> <pre><code>from orchestrator import tool\n\n@tool(domain=\"demo\")\nasync def echo(message: str) -&gt; dict:\n    return {\"echo\": message}\n</code></pre> <ul> <li>Returns: Registered tool callable.</li> <li>Links: Decorators, Samples</li> </ul>"},{"location":"reference/api-python/exports/discovery/browse_tools/","title":"<code>browse_tools</code>","text":"<ul> <li>What: Progressive detail browsing for CLI/UX.</li> <li>When: Guided exploration flows.</li> <li>Example:</li> </ul> <pre><code>from orchestrator import browse_tools\nprint(browse_tools(query=\"github\"))\n</code></pre> <ul> <li>Links: Discovery, CLI</li> </ul>"},{"location":"reference/api-python/exports/discovery/get_available_tools/","title":"<code>get_available_tools</code>","text":"<ul> <li>What: Return all registered tools.</li> <li>When: Bootstrap catalogs for planners or REST adapters.</li> <li>Example:</li> </ul> <pre><code>from orchestrator import get_available_tools\nprint(len(get_available_tools()))\n</code></pre> <ul> <li>Links: Discovery</li> </ul>"},{"location":"reference/api-python/exports/discovery/get_tool_info/","title":"<code>get_tool_info</code>","text":"<ul> <li>What: Detailed definition for a tool by name.</li> <li>When: Render schemas in UI; validate parameters.</li> <li>Example:</li> </ul> <pre><code>from orchestrator import get_tool_info\nprint(get_tool_info(\"receipt_ocr\"))\n</code></pre> <ul> <li>Links: Discovery</li> </ul>"},{"location":"reference/api-python/exports/discovery/list_tools_by_domain/","title":"<code>list_tools_by_domain</code>","text":"<ul> <li>What: List tools that share a domain.</li> <li>Example:</li> </ul> <pre><code>from orchestrator import list_tools_by_domain\nprint(list_tools_by_domain(\"finance\"))\n</code></pre> <ul> <li>Links: Discovery</li> </ul>"},{"location":"reference/api-python/exports/discovery/search_tools/","title":"<code>search_tools</code>","text":"<ul> <li>What: Filter tools by domain/keywords.</li> <li>When: Narrow selection for a task.</li> <li>Example:</li> </ul> <pre><code>from orchestrator import search_tools\nprint([t.name for t in search_tools(domain=\"github\")])\n</code></pre> <ul> <li>Links: Discovery</li> </ul>"},{"location":"reference/api-python/exports/discovery/semantic_search_tools/","title":"<code>semantic_search_tools</code>","text":"<ul> <li>What: Semantic matching against tool descriptions.</li> <li>When: Natural language discovery.</li> <li>Example:</li> </ul> <pre><code>from orchestrator import semantic_search_tools\nprint(semantic_search_tools(query=\"process receipts\"))\n</code></pre> <ul> <li>Links: Discovery</li> </ul>"},{"location":"reference/api-python/exports/logging/enable_debug_mode/","title":"<code>enable_debug_mode</code>","text":"<ul> <li>What: Install secrets redactor and enable debug-friendly logging.</li> <li>When: Prevent credentials from appearing in logs.</li> <li>Example:</li> </ul> <pre><code>from orchestrator import enable_debug_mode\nenable_debug_mode()\n</code></pre> <ul> <li>Links: Logging, Version &amp; Security</li> </ul>"},{"location":"reference/api-python/exports/logging/get_logger/","title":"<code>get_logger</code>","text":"<ul> <li>What: Get a module-specific logger.</li> <li>When: Emit logs with secrets-safe behavior.</li> <li>Example:</li> </ul> <pre><code>from orchestrator import get_logger\nlogger = get_logger(__name__)\nlogger.info(\"hello\")\n</code></pre> <ul> <li>Links: Logging</li> </ul>"},{"location":"reference/api-python/exports/logging/set_log_level/","title":"<code>set_log_level</code>","text":"<ul> <li>What: Set global log level.</li> <li>When: Control verbosity across the package.</li> <li>Example:</li> </ul> <pre><code>from orchestrator import set_log_level\nset_log_level(\"INFO\")\n</code></pre> <ul> <li>Links: Logging</li> </ul>"},{"location":"reference/api-python/exports/plugins/discover_plugins/","title":"<code>discover_plugins</code>","text":"<ul> <li>What: Scan and register discoverable plugins.</li> <li>When: Auto-load plugins from configured locations.</li> <li>Links: Plugins</li> </ul>"},{"location":"reference/api-python/exports/plugins/get_plugin/","title":"<code>get_plugin</code>","text":"<ul> <li>What: Retrieve a plugin instance by name.</li> <li>When: Inspect or interact with plugin state.</li> <li>Links: Plugins</li> </ul>"},{"location":"reference/api-python/exports/plugins/list_plugins/","title":"<code>list_plugins</code>","text":"<ul> <li>What: List registered plugins.</li> <li>When: Inspect current extensions.</li> <li>Links: Plugins</li> </ul>"},{"location":"reference/api-python/exports/plugins/register_plugin/","title":"<code>register_plugin</code>","text":"<ul> <li>What: Register a plugin instance.</li> <li>When: Extend ToolWeaver with new behaviors or sources.</li> <li>Example:</li> </ul> <pre><code>from orchestrator import register_plugin\nclass MyPlugin:\n    def setup(self):\n        print(\"hello\")\nregister_plugin(\"my_plugin\", MyPlugin())\n</code></pre> <ul> <li>Links: Plugins</li> </ul>"},{"location":"reference/api-python/exports/plugins/unregister_plugin/","title":"<code>unregister_plugin</code>","text":"<ul> <li>What: Remove a plugin by name.</li> <li>When: Disable or replace behavior.</li> <li>Links: Plugins</li> </ul>"},{"location":"reference/api-python/exports/skill-bridge/get_skill_backed_tools/","title":"<code>get_skill_backed_tools</code>","text":"<ul> <li>What: List tools backed by skills.</li> <li>When: Discover reusable, approved tools.</li> <li>Links: Skill Bridge</li> </ul>"},{"location":"reference/api-python/exports/skill-bridge/get_tool_skill/","title":"<code>get_tool_skill</code>","text":"<ul> <li>What: Get skill metadata for a registered tool.</li> <li>When: Inspect linkage and provenance.</li> <li>Links: Skill Bridge</li> </ul>"},{"location":"reference/api-python/exports/skill-bridge/load_tool_from_skill/","title":"<code>load_tool_from_skill</code>","text":"<ul> <li>What: Load a skill-backed tool.</li> <li>When: Reuse approved tools.</li> <li>Example:</li> </ul> <pre><code>from orchestrator import load_tool_from_skill\ntool = load_tool_from_skill(\"echo\", org=\"acme\")\nprint(tool)\n</code></pre> <ul> <li>Links: Skill Bridge</li> </ul>"},{"location":"reference/api-python/exports/skill-bridge/save_tool_as_skill/","title":"<code>save_tool_as_skill</code>","text":"<ul> <li>What: Persist a tool as a reusable skill package.</li> <li>When: Share tools across environments/teams.</li> <li>Example:</li> </ul> <pre><code>from orchestrator import save_tool_as_skill, mcp_tool\n\n@mcp_tool(domain=\"demo\")\nasync def echo(message: str) -&gt; dict:\n    return {\"echo\": message}\n\nsave_tool_as_skill(\"echo\", org=\"acme\")\n</code></pre> <ul> <li>Links: Skill Bridge</li> </ul>"},{"location":"reference/api-python/exports/skill-bridge/sync_tool_with_skill/","title":"<code>sync_tool_with_skill</code>","text":"<ul> <li>What: Synchronize tool changes to its skill package.</li> <li>When: Keep skill registry updated.</li> <li>Links: Skill Bridge</li> </ul>"},{"location":"reference/api-python/exports/templates/agent_template/","title":"<code>AgentTemplate</code>","text":"<ul> <li>What: Define agent-style tools (evaluators, classifiers).</li> <li>When: Provide consistent schema and lifecycle around agent calls.</li> <li>Links: Templates, Parallel Agents</li> </ul>"},{"location":"reference/api-python/exports/templates/base_template/","title":"<code>BaseTemplate</code>","text":"<ul> <li>What: Abstract base for tool templates.</li> <li>When: Build custom template behaviors beyond built-ins.</li> <li>How: Subclass and implement <code>run()</code>; define <code>name</code>, <code>description</code>, <code>parameters</code>.</li> <li>Links: Templates</li> </ul>"},{"location":"reference/api-python/exports/templates/code_exec_tool_template/","title":"<code>CodeExecToolTemplate</code>","text":"<ul> <li>What: Execute user-provided code with sandbox controls.</li> <li>When: Safe code execution tasks with timeouts and restricted builtins.</li> <li>Links: Sandbox Execution, Templates</li> </ul>"},{"location":"reference/api-python/exports/templates/function_tool_template/","title":"<code>FunctionToolTemplate</code>","text":"<ul> <li>What: Define function-style tools with explicit schema.</li> <li>When: Need strong parameter control or validation.</li> <li>Example:</li> </ul> <pre><code>from orchestrator import FunctionToolTemplate\nfrom orchestrator.shared.models import ToolParameter\n\nclass AddTool(FunctionToolTemplate):\n    name = \"add\"\n    description = \"Sum two numbers\"\n    parameters = [\n        ToolParameter(name=\"a\", type=\"number\", required=True),\n        ToolParameter(name=\"b\", type=\"number\", required=True),\n    ]\n    async def run(self, a: float, b: float) -&gt; dict:\n        return {\"sum\": a + b}\n</code></pre> <ul> <li>Links: Templates, Samples</li> </ul>"},{"location":"reference/api-python/exports/templates/mcp_tool_template/","title":"<code>MCPToolTemplate</code>","text":"<ul> <li>What: MCP-flavored template with richer discovery metadata.</li> <li>When: Exposing tools to MCP-based planners/adapters.</li> <li>Links: Templates</li> </ul>"},{"location":"reference/api-python/exports/version-security/__version__/","title":"<code>__version__</code>","text":"<ul> <li>What: Package version string.</li> <li>When: Display version in logs or UIs.</li> <li>Example:</li> </ul> <pre><code>import orchestrator\nprint(orchestrator.__version__)\n</code></pre> <ul> <li>Links: Version &amp; Security</li> </ul>"},{"location":"reference/api-python/exports/version-security/secrets_redactor/","title":"<code>secrets redactor</code>","text":"<ul> <li>What: Auto-installed redactor to prevent secrets appearing in logs.</li> <li>When: On import; combine with <code>enable_debug_mode()</code> for safe logging.</li> <li>Links: Logging, Version &amp; Security</li> </ul>"},{"location":"reference/api-python/exports/yaml-loaders/WorkerResolutionError/","title":"<code>WorkerResolutionError</code>","text":"<ul> <li>What: Referenced worker/tool backend cannot be resolved.</li> <li>When: Catch to diagnose environment or plugin issues.</li> <li>Links: YAML Loaders</li> </ul>"},{"location":"reference/api-python/exports/yaml-loaders/YAMLLoaderError/","title":"<code>YAMLLoaderError</code>","text":"<ul> <li>What: General error during YAML loading (file IO, parse failure).</li> <li>When: Catch to diagnose file-level issues.</li> <li>Links: YAML Loaders</li> </ul>"},{"location":"reference/api-python/exports/yaml-loaders/YAMLValidationError/","title":"<code>YAMLValidationError</code>","text":"<ul> <li>What: Schema invalid (missing fields, wrong types).</li> <li>When: Catch to present user-friendly validation feedback.</li> <li>Links: YAML Loaders</li> </ul>"},{"location":"reference/api-python/exports/yaml-loaders/load_tools_from_directory/","title":"<code>load_tools_from_directory</code>","text":"<ul> <li>What: Load tool definitions from a directory of YAML files.</li> <li>When: Bulk registration.</li> <li>Example:</li> </ul> <pre><code>from orchestrator import load_tools_from_directory\nload_tools_from_directory(\"./tools_yaml\")\n</code></pre> <ul> <li>Errors: <code>YAMLLoaderError</code>, <code>YAMLValidationError</code>, <code>WorkerResolutionError</code></li> <li>Links: YAML Loaders</li> </ul>"},{"location":"reference/api-python/exports/yaml-loaders/load_tools_from_yaml/","title":"<code>load_tools_from_yaml</code>","text":"<ul> <li>What: Load tool definitions from a YAML file.</li> <li>When: Config-driven registration.</li> <li>Example:</li> </ul> <pre><code>from orchestrator import load_tools_from_yaml\nload_tools_from_yaml(\"add.yaml\")\n</code></pre> <ul> <li>Errors: <code>YAMLLoaderError</code>, <code>YAMLValidationError</code></li> <li>Links: YAML Loaders</li> </ul>"},{"location":"reference/api-rest/","title":"REST API","text":"<ul> <li>Overview</li> <li>List Tools</li> <li>Get Tool</li> <li>Execute Tool</li> <li>MCP Adapter</li> </ul>"},{"location":"reference/api-rest/execute-tool/","title":"Execute Tool","text":"<ul> <li>Method: POST</li> <li>Path: <code>/api/v1/tools/{tool_name}/execute</code></li> <li>Purpose: run a tool with given parameters</li> </ul>"},{"location":"reference/api-rest/execute-tool/#request-body","title":"Request Body","text":"<pre><code>{\n  \"params\": {\n    \"image_path\": \"s3://bucket/receipt.jpg\"\n  }\n}\n</code></pre>"},{"location":"reference/api-rest/execute-tool/#example-curl","title":"Example (curl)","text":"<pre><code>curl -s -X POST \\\n  http://localhost:8000/api/v1/tools/receipt_ocr/execute \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"params\": {\"image_path\": \"/tmp/receipt.jpg\"}}' | jq .\n</code></pre>"},{"location":"reference/api-rest/execute-tool/#example-python","title":"Example (Python)","text":"<pre><code>import requests\npayload = {\"params\": {\"image_path\": \"/tmp/receipt.jpg\"}}\nresp = requests.post(\"http://localhost:8000/api/v1/tools/receipt_ocr/execute\", json=payload)\nprint(resp.json())\n</code></pre>"},{"location":"reference/api-rest/execute-tool/#response-example","title":"Response (example)","text":"<pre><code>{\n  \"text\": \"Receipt total $10.99 ...\",\n  \"confidence\": 0.92\n}\n</code></pre>"},{"location":"reference/api-rest/execute-tool/#errors","title":"Errors","text":"<ul> <li>404 if <code>tool_name</code> not found</li> <li>400 if parameters are invalid</li> </ul>"},{"location":"reference/api-rest/execute-tool/#links","title":"Links","text":"<ul> <li>Server adapter: orchestrator/adapters/fastapi_wrapper.py</li> <li>Samples: samples/09-code-execution</li> </ul>"},{"location":"reference/api-rest/get-tool/","title":"Get Tool Details","text":"<ul> <li>Method: GET</li> <li>Path: <code>/api/v1/tools/{tool_name}</code></li> <li>Purpose: retrieve full schema for a specific tool</li> </ul>"},{"location":"reference/api-rest/get-tool/#example-curl","title":"Example (curl)","text":"<pre><code>curl -s http://localhost:8000/api/v1/tools/receipt_ocr | jq .\n</code></pre>"},{"location":"reference/api-rest/get-tool/#example-python","title":"Example (Python)","text":"<pre><code>import requests\nresp = requests.get(\"http://localhost:8000/api/v1/tools/receipt_ocr\")\nprint(resp.json())\n</code></pre>"},{"location":"reference/api-rest/get-tool/#response-example","title":"Response (example)","text":"<pre><code>{\n  \"name\": \"receipt_ocr\",\n  \"description\": \"Extracts text from receipt images\",\n  \"type\": \"function\",\n  \"provider\": \"python\",\n  \"parameters\": [\n    {\n      \"name\": \"image_path\",\n      \"type\": \"string\",\n      \"description\": \"Local or S3 path\",\n      \"required\": true,\n      \"enum\": null\n    }\n  ],\n  \"metadata\": {}\n}\n</code></pre>"},{"location":"reference/api-rest/get-tool/#links","title":"Links","text":"<ul> <li>Server adapter: orchestrator/adapters/fastapi_wrapper.py</li> <li>Samples: samples/03-github-operations</li> </ul>"},{"location":"reference/api-rest/list-tools/","title":"List Tools","text":"<ul> <li>Method: GET</li> <li>Path: <code>/api/v1/tools</code></li> <li>Purpose: enumerate all available tools with summary schemas</li> </ul>"},{"location":"reference/api-rest/list-tools/#example-curl","title":"Example (curl)","text":"<pre><code>curl -s http://localhost:8000/api/v1/tools | jq .\n</code></pre>"},{"location":"reference/api-rest/list-tools/#example-python","title":"Example (Python)","text":"<pre><code>import requests\nresp = requests.get(\"http://localhost:8000/api/v1/tools\")\nprint(resp.json())\n</code></pre>"},{"location":"reference/api-rest/list-tools/#response-example","title":"Response (example)","text":"<pre><code>{\n  \"count\": 3,\n  \"tools\": [\n    {\n      \"name\": \"receipt_ocr\",\n      \"description\": \"Extracts text from receipt images\",\n      \"type\": \"function\",\n      \"parameters\": [\n        {\"name\": \"image_path\", \"type\": \"string\", \"description\": \"Local or S3 path\", \"required\": true}\n      ]\n    },\n    {\n      \"name\": \"categorize_expenses\",\n      \"description\": \"Categorize line items\",\n      \"type\": \"function\",\n      \"parameters\": [\n        {\"name\": \"items\", \"type\": \"array\", \"description\": \"Line items\", \"required\": true}\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"reference/api-rest/list-tools/#links","title":"Links","text":"<ul> <li>Server adapter: orchestrator/adapters/fastapi_wrapper.py</li> <li>Tools examples: samples/03-github-operations</li> <li>Concepts: Tools &amp; Discovery</li> </ul>"},{"location":"reference/api-rest/mcp-adapter/","title":"MCP Adapter Endpoints","text":"<p>A minimal external adapter (sample) exposing two endpoints.</p> <p>Sample server: samples/24-external-mcp-adapter/server.py</p>"},{"location":"reference/api-rest/mcp-adapter/#list-tools","title":"List Tools","text":"<ul> <li>Method: GET</li> <li>Path: <code>/tools</code></li> </ul> <p>Example:</p> <pre><code>curl -s http://localhost:8080/tools | jq .\n</code></pre>"},{"location":"reference/api-rest/mcp-adapter/#execute","title":"Execute","text":"<ul> <li>Method: POST</li> <li>Path: <code>/execute</code></li> <li>Body:</li> </ul> <pre><code>{\"name\": \"process_user\", \"params\": {\"user\": {\"id\": 123, \"name\": \"Ada\"}}}\n</code></pre> <p>Example:</p> <pre><code>curl -s -X POST http://localhost:8080/execute \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"name\": \"process_user\", \"params\": {\"user\": {\"id\": 123}}}' | jq .\n</code></pre>"},{"location":"reference/api-rest/mcp-adapter/#why","title":"Why","text":"<ul> <li>Simple demo for integrating external tools/services.</li> <li>Echo-style responses illustrate payload structure.</li> </ul>"},{"location":"reference/api-rest/mcp-adapter/#links","title":"Links","text":"<ul> <li>Sample server: samples/24-external-mcp-adapter/server.py</li> </ul>"},{"location":"reference/api-rest/overview/","title":"REST API Overview","text":"<p>Expose ToolWeaver tools over HTTP using the FastAPI adapter.</p> <ul> <li>Base URL: <code>/api/v1</code> (configurable)</li> <li>Endpoints: list tools, get tool details, execute tool</li> <li>Why: let any service (browser, server, CLI) call your tools safely</li> </ul>"},{"location":"reference/api-rest/overview/#start-the-server","title":"Start the server","text":"<p>Create a FastAPI app exposing your current tool catalog.</p> <pre><code>from orchestrator import get_available_tools\nfrom orchestrator.adapters import FastAPIAdapter\n\n# Discover tools (decorators, YAML, templates)\ntools = get_available_tools()\n\n# Create REST API\nadapter = FastAPIAdapter(tools, base_url=\"/api/v1\")\napp = adapter.create_app()\n\n# Run with uvicorn:\n# uvicorn main:app --reload --port 8000\n</code></pre> <ul> <li>Tools are read-only endpoints except execution.</li> <li>Requests/Responses are simple JSON where parameters map to tool schemas.</li> </ul>"},{"location":"reference/api-rest/overview/#endpoints","title":"Endpoints","text":"<ul> <li>List tools: GET <code>/api/v1/tools</code> \u2014 browse available tools</li> <li>Tool details: GET <code>/api/v1/tools/{tool_name}</code> \u2014 full schema &amp; metadata</li> <li>Execute tool: POST <code>/api/v1/tools/{tool_name}/execute</code> \u2014 run with params</li> </ul> <p>Continue to: - List Tools - Get Tool - Execute Tool - MCP Adapter Endpoints</p>"},{"location":"reference/deep-dives/","title":"Deep Dives","text":"<p>Architecture and operational deep dives for planners, search, caching, analytics, and migration.</p> <ul> <li>Two-Model Architecture \u2014 Large-planner + small-executor split and cost model.</li> <li>Workflow Architecture \u2014 DAG execution, dispatch, retries, and safety rails.</li> <li>Registry Discovery \u2014 Tool registry shape, discovery paths, and search integration.</li> <li>Search Tuning \u2014 BM25 + embeddings hybrid, thresholds, and ranking knobs.</li> <li>Prompt Caching \u2014 Layered caching and provider behaviors (Anthropic/OpenAI).</li> <li>Analytics Guide \u2014 Metrics backends, schema, and when to pick Prometheus/OTLP/SQLite.</li> <li>Skill Library \u2014 Managing reusable skills and catalog hygiene.</li> <li>Small Model Improvements \u2014 Using lightweight models for execution and cost savings.</li> <li>Hybrid Model Routing \u2014 Route tasks across small and large models with thresholds and fallbacks.</li> <li>Control Flow Patterns \u2014 Sequence/branch/map-reduce, retries, and circuit breakers.</li> <li>Agent Delegation \u2014 Hand off tasks across specialized agents with A2A.</li> <li>Multi-Agent Coordination \u2014 Fan-out/fan-in with quotas, idempotency, and aggregation.</li> <li>Error Recovery \u2014 Classify failures, backoff retries, and compensating actions.</li> <li>Skills Packaging &amp; Reuse \u2014 Versioned tool reuse via the skill library.</li> <li>Plugin Extension \u2014 Extend ToolWeaver at runtime with plugins.</li> <li>Idempotency &amp; Retry \u2014 Guardrails for parallel dispatch and safe retries.</li> <li>REST API Usage \u2014 Call tools over HTTP from external clients.</li> </ul>"},{"location":"reference/deep-dives/agent-delegation/","title":"Agent Delegation","text":""},{"location":"reference/deep-dives/agent-delegation/#simple-explanation","title":"Simple Explanation","text":"<p>Let one agent hand off a task to another specialized agent. Discover available agents, match by capability, and delegate with clear inputs/outputs.</p>"},{"location":"reference/deep-dives/agent-delegation/#technical-explanation","title":"Technical Explanation","text":"<p>Use an A2A (agent-to-agent) client and registry: discover agents and their tools via metadata or YAML, select candidates by capability tags, and execute remotely with well-defined payloads. Track delegation outcomes for learning.</p> <p>When to use - Specialized agents (e.g., data extraction vs analysis) working together - Cross-boundary execution in separate processes or services</p> <p>Key Primitives - Agent registry and metadata - A2A client for remote tool execution - Capability-based selection and scoring - Audit logs and feedback loops</p> <p>Try it - Discover agents: samples/16-agent-delegation/discover_agents.py - Delegate tasks: samples/16-agent-delegation/delegate_to_agent.py - See the README: samples/16-agent-delegation/README.md</p> <p>Gotchas - Validate payload schemas across agents to avoid decoding issues - Prevent circular delegation; enforce max hops and tracing - Handle auth/permissions if agents run in different domains</p>"},{"location":"reference/deep-dives/analytics-guide/","title":"Analytics Guide","text":"<p>Choose a metrics backend and understand what is emitted.</p> <p>Backends - OTLP (Grafana Cloud): managed, simple; push over HTTP. - Prometheus: self-hosted scrape; exposes /metrics. - SQLite: local dev, file-based.</p> <p>Metrics - Execution counts (success/failure) - Latency histogram - Ratings and health scores</p> <p>Setup - Select backend via env (<code>ANALYTICS_BACKEND=otlp|prometheus|sqlite</code>). - For OTLP: set endpoint, instance id, token, push interval. - For Prometheus: enable metrics server (host/port) and configure scrape job.</p> <p>Operational tips - Prefer OTLP/Prometheus in production; SQLite only for local dev. - Watch cardinality; keep metric labels bounded. - Use alerts on error rate and latency p95/p99.</p>"},{"location":"reference/deep-dives/control-flow-patterns/","title":"Control Flow Patterns","text":""},{"location":"reference/deep-dives/control-flow-patterns/#simple-explanation","title":"Simple Explanation","text":"<p>Common orchestration patterns to structure complex workflows: sequence, branch, map/reduce, retry with backoff, and circuit breakers. Use them to keep workflows predictable and resilient.</p>"},{"location":"reference/deep-dives/control-flow-patterns/#technical-explanation","title":"Technical Explanation","text":"<p>Compose tasks using explicit control flow: DAG or step functions. Implement branching by predicates, fan-out/fan-in for parallel work, and resilience via retries, backoff, and circuit breakers. Track idempotency keys to avoid duplicate work.</p> <p>When to use - Multi-step workflows with conditional paths - Parallelizable subtasks with aggregation - External dependencies that can fail intermittently</p> <p>Key Primitives - DAG planner or step executor - Branch predicates and guards - Fan-out/fan-in with concurrency limits - Retry/backoff; circuit breaker; idempotency cache</p> <p>Try it - Run the sample: samples/15-control-flow/demo_patterns.py - See the README: samples/15-control-flow/README.md</p> <p>Gotchas - Keep side-effects behind idempotent interfaces - Make aggregation robust to partial failures - Add timeouts and budget limits per branch</p>"},{"location":"reference/deep-dives/error-recovery/","title":"Error Recovery","text":""},{"location":"reference/deep-dives/error-recovery/#simple-explanation","title":"Simple Explanation","text":"<p>Design workflows that keep going when parts fail. Detect errors, retry safely, skip when appropriate, and record what happened.</p>"},{"location":"reference/deep-dives/error-recovery/#technical-explanation","title":"Technical Explanation","text":"<p>Use explicit error handling: classify failures (transient vs permanent), apply retries with backoff for transient cases, and fall back or skip for permanent ones. Track idempotency keys to avoid duplicates, and record events for auditing.</p> <p>When to use - External dependencies with intermittent errors - Long-running workflows where partial success is acceptable</p> <p>Key Primitives - Error taxonomy and handlers - Retry/backoff and skip/fallback policies - Idempotency and event logs - Compensating actions for side-effects</p> <p>Try it - Run the workflow: samples/21-error-recovery/workflow.py - Tests and examples: samples/21-error-recovery/test_example.py - See the README: samples/21-error-recovery/README.md</p> <p>Gotchas - Keep retries bounded; avoid infinite loops - Make side-effects compensable or idempotent - Distinguish user errors from system errors for correct policies</p>"},{"location":"reference/deep-dives/hybrid-model-routing/","title":"Hybrid Model Routing","text":""},{"location":"reference/deep-dives/hybrid-model-routing/#simple-explanation","title":"Simple Explanation","text":"<p>Use multiple models together: fast, cheap models for easy tasks and bigger models for hard cases. Route requests based on confidence, cost, or explicit rules, and add fallbacks when the first choice fails.</p>"},{"location":"reference/deep-dives/hybrid-model-routing/#technical-explanation","title":"Technical Explanation","text":"<p>Implement a router that scores tasks by complexity/uncertainty (e.g., heuristics or LLM self-estimates) and selects a model backend accordingly. Combine thresholds, guardrails, and retries with fallback escalation. Log decisions and outcomes to tune thresholds over time.</p> <p>When to use - Large volume with mixed difficulty and tight latency/cost budgets - Quality-sensitive paths needing escalation to stronger models</p> <p>Key Primitives - Scoring/thresholds: difficulty, confidence, domain tags - Backends: small vs large model clients - Fallbacks &amp; retries: escalate on low confidence or errors - Observability: decision logs and success metrics</p> <p>Try it - Run the sample: samples/08-hybrid-model-routing/hybrid_routing_demo.py - See the README: samples/08-hybrid-model-routing/README.md</p> <p>Gotchas - Avoid flapping by adding hysteresis and minimum confidence deltas - Capture routing features so you can reproduce and debug decisions - Guard against runaway retries; cap attempts and escalate deterministically</p>"},{"location":"reference/deep-dives/idempotency-retry/","title":"Idempotency &amp; Retry (Dispatch)","text":""},{"location":"reference/deep-dives/idempotency-retry/#simple-explanation","title":"Simple Explanation","text":"<p>Run many agent calls safely: avoid duplicate work with idempotency keys, enforce timeouts and rate limits, and apply fail\u2011fast policies.</p>"},{"location":"reference/deep-dives/idempotency-retry/#technical-explanation","title":"Technical Explanation","text":"<p>Use <code>dispatch_agents()</code> with <code>DispatchResourceLimits</code> for quotas and tracking. Idempotency cache stores results by key; repeated inputs return cached outputs. Rate limiter controls request pace; timeouts and failure\u2011rate guards enforce resilience.</p> <p>When to use - Parallel orchestration with potential retries - Budget and reliability constraints</p> <p>Key Primitives - <code>dispatch_agents()</code> \u2014 parallel execution with guardrails - <code>DispatchResourceLimits</code> \u2014 quotas and thresholds - Idempotency cache \u2014 avoids duplicates</p> <p>Try it - Run the sample: samples/32-idempotency-retry/idempotency_retry_demo.py - See the README: samples/32-idempotency-retry/README.md</p> <p>Why run this - See cache hits in action for duplicate inputs - Observe timeouts and failure\u2011rate guards under load - Tune rate limits and quotas to your API budgets</p> <p>Gotchas - Bound retries; treat timeouts as failures when appropriate - Tune rate limits to API quotas - Use deterministic aggregation for partial results</p>"},{"location":"reference/deep-dives/migration-guide/","title":"Migration Guide","text":"<p>Notes for upgrading between ToolWeaver versions.</p> <p>General steps - Pin versions in production; test upgrades in staging. - Review changelog for breaking changes (API signatures, env vars). - Re-run <code>load_tools_from_directory</code> to validate YAML schemas after upgrades.</p> <p>Common areas to check - Decorator/template parameters that tightened validation. - Registry/discovery defaults (top-k, thresholds). - Analytics backend env vars (e.g., OTLP/Prometheus flags). - Cache locations and TTL defaults.</p> <p>Testing - Run unit tests and <code>examples/test_all_examples.py</code> with representative env vars. - Validate REST endpoints if you expose the FastAPI adapter.</p>"},{"location":"reference/deep-dives/multi-agent-coordination/","title":"Multi-Agent Coordination","text":""},{"location":"reference/deep-dives/multi-agent-coordination/#simple-explanation","title":"Simple Explanation","text":"<p>Coordinate multiple agents to work on parts of a problem in parallel, then combine the results. Use semaphores, quotas, and clear roles.</p>"},{"location":"reference/deep-dives/multi-agent-coordination/#technical-explanation","title":"Technical Explanation","text":"<p>Define roles and tasks, assign agents based on capabilities, and use a coordinator to manage fan-out/fan-in with resource limits and idempotency keys. Aggregate outputs deterministically and record provenance.</p> <p>When to use - Complex tasks that decompose into parallelizable subtasks - Teams of specialized agents with shared context</p> <p>Key Primitives - Role definitions and task decomposition - Coordinator with concurrency controls - Idempotency cache and provenance tracking - Deterministic aggregation and conflict resolution</p> <p>Try it - Coordinate agents: samples/17-multi-agent-coordination/coordinate_agents.py - See the README: samples/17-multi-agent-coordination/README.md</p> <p>Gotchas - Avoid race conditions; use clear ownership and locks - Keep shared context small; pass references not blobs - Handle stragglers with timeouts and partial aggregates</p>"},{"location":"reference/deep-dives/plugin-extension/","title":"Plugin Extension","text":""},{"location":"reference/deep-dives/plugin-extension/#simple-explanation","title":"Simple Explanation","text":"<p>Add tools to ToolWeaver without modifying core code by registering a plugin that provides tools and an execution method.</p>"},{"location":"reference/deep-dives/plugin-extension/#technical-explanation","title":"Technical Explanation","text":"<p>Plugins implement <code>get_tools()</code> and <code>execute()</code>. Register at runtime with <code>register_plugin(name, plugin)</code>, retrieve via <code>get_plugin(name)</code>, list with <code>list_plugins()</code>. The registry validates names, uniqueness, and interface compliance.</p> <p>When to use - Third\u2011party integrations or domain\u2011specific tools - Runtime extensions in apps without forking core</p> <p>Key Primitives - <code>register_plugin()</code> / <code>unregister_plugin()</code> - <code>get_plugin()</code> / <code>list_plugins()</code> / <code>discover_plugins()</code> - <code>PluginProtocol</code> \u2014 required interface</p> <p>Try it - Run the sample: samples/31-plugin-extension/plugin_demo.py - See the README: samples/31-plugin-extension/README.md</p> <p>Why run this - Add tools at runtime without forking core code - Validate plugin interface and registry behavior quickly - Prototype integrations to gauge fit before packaging</p> <p>Gotchas - Enforce unique tool names across plugins - Handle async <code>execute()</code> correctly; return structured dicts - Use entry points for discovery in packaged plugins</p>"},{"location":"reference/deep-dives/prompt-caching/","title":"Prompt Caching","text":"<p>Multi-layer caching to cut cost and latency.</p> <p>Layers - Tool discovery cache: serialized tool metadata for fast lookup. - Embedding cache: reuse embeddings for repeated tool texts. - Query cache: reuse search results for recurring queries. - LLM prompt cache: provider-side (Anthropic/OpenAI) discounts for repeated prompts/tooldefs.</p> <p>Guidelines - Tune TTLs per layer: short for queries, longer for embeddings and tool defs. - Normalize tool definitions to maximize cache hits. - Log cache hit rates; adjust before scaling traffic.</p>"},{"location":"reference/deep-dives/registry-discovery/","title":"Registry Discovery","text":"<p>How ToolWeaver builds and queries the tool catalog.</p> <p>Sources - MCP servers (remote/local) - Python decorators/templates - YAML loaders</p> <p>Indexing - Normalizes name/domain/description/parameters. - Stores examples to improve planner grounding.</p> <p>Discovery paths - <code>get_available_tools</code> for full listings - <code>search_tools</code> for filtered sets (domain/keywords) - <code>semantic_search_tools</code> for NL queries (BM25 + embeddings)</p> <p>Best practices - Keep descriptions concise and specific. - Provide examples for better planner parameter filling. - Use domains to scope planner search and reduce tokens.</p>"},{"location":"reference/deep-dives/rest-api-usage/","title":"REST API Usage","text":""},{"location":"reference/deep-dives/rest-api-usage/#simple-explanation","title":"Simple Explanation","text":"<p>Call ToolWeaver tools over HTTP: list available tools, inspect details, and execute a tool by posting parameters.</p>"},{"location":"reference/deep-dives/rest-api-usage/#technical-explanation","title":"Technical Explanation","text":"<p>Expose tools via a service (e.g., FastAPI). Clients call the REST endpoints to discover and run tools remotely. Ensure consistent schemas and auth where needed.</p> <p>Endpoints - <code>GET /tools</code> \u2014 list tools - <code>GET /tools/{name}</code> \u2014 tool details - <code>POST /tools/{name}/execute</code> \u2014 run tool</p> <p>Try it - Run the client sample: samples/29-rest-api-usage/rest_client_demo.py - See the README: samples/29-rest-api-usage/README.md</p> <p>Why run this - Verify HTTP integration from non\u2011Python clients - Inspect endpoint shapes and payloads end\u2011to\u2011end - Validate service wiring before building full apps</p> <p>Gotchas - Validate inputs server\u2011side; enforce timeouts and rate limits - Log with secrets redaction; avoid sensitive data exposure - Version your API routes for compatibility</p>"},{"location":"reference/deep-dives/search-tuning/","title":"Search Tuning","text":"<p>Hybrid retrieval (BM25 + embeddings) drives tool selection.</p> <p>Levers - Domain filter: narrow early when the request is scoped. - Top-k: balance recall vs token cost (e.g., 5\u201310 tools to planner). - Embedding model: 384-dim (MiniLM) by default; larger models for nuance at higher cost. - Thresholds: drop low-similarity hits to avoid planner confusion.</p> <p>Caching - Cache discovery results for common queries to reduce latency and token use.</p> <p>Evaluation - Track hit quality and planner success rates; adjust thresholds and top-k accordingly.</p>"},{"location":"reference/deep-dives/skill-library/","title":"Skill Library","text":"<p>Managing reusable skills as packaged tools.</p> <p>Key actions - Save tools as skills for reuse (<code>save_tool_as_skill</code>). - Load skills where needed (<code>load_tool_from_skill</code>). - Sync updates from source tools back to skills. - List skill-backed tools to audit coverage.</p> <p>Hygiene tips - Version skills and record domains/descriptions consistently. - Re-run validation after upgrades to catch schema drift. - Store skills in a controlled path/shared store for teams.</p>"},{"location":"reference/deep-dives/skills-packaging/","title":"Skills Packaging &amp; Reuse","text":""},{"location":"reference/deep-dives/skills-packaging/#simple-explanation","title":"Simple Explanation","text":"<p>Save a tool as a reusable skill, load it back later, and keep tools synced to the latest skill version.</p>"},{"location":"reference/deep-dives/skills-packaging/#technical-explanation","title":"Technical Explanation","text":"<p>Use <code>save_tool_as_skill()</code> to persist a tool's source and metadata into the skill library, <code>load_tool_from_skill()</code> to reconstruct a runnable tool (definition + function), and <code>sync_tool_with_skill()</code> to update a tool to the latest version. This enables versioning and sharing across projects.</p> <p>When to use - You want a portable, versioned catalog of tools across teams - You need to pin or upgrade tool versions deterministically</p> <p>Key Primitives - <code>save_tool_as_skill()</code> \u2014 persist source + metadata - <code>load_tool_from_skill()</code> \u2014 reconstruct tool from library - <code>sync_tool_with_skill()</code> \u2014 update to latest version - <code>get_tool_skill()</code> \u2014 view backing skill metadata</p> <p>Try it - Run the sample: samples/30-skills-packaging/skills_demo.py - See the README: samples/30-skills-packaging/README.md</p> <p>Why run this - Establish a versioned tool catalog for teams - Practice saving/loading tools as skills without changing app code - Learn how to sync tools across environments reproducibly</p> <p>Gotchas - Ensure decorators are stripped when saving source; library runs plain functions - Use semantic versioning to communicate changes - Validate payload schemas across versions to prevent runtime breaks</p>"},{"location":"reference/deep-dives/small-model-improvements/","title":"Small Model Improvements","text":"<p>Use lightweight models for execution to save cost while keeping quality acceptable.</p> <p>Guidelines - Use small models (e.g., Phi-3, Llama variants) for extraction/classification/routing; keep large models for planning. - Calibrate prompts for small models with few-shot examples; keep outputs structured. - Cache aggressively when small models are deterministic enough.</p> <p>When to fall back to large models - Complex reasoning, synthesis, or when small model confidence drops. - Cold-start scenarios without cached context.</p>"},{"location":"reference/deep-dives/two-model-architecture/","title":"Two-Model Architecture","text":""},{"location":"reference/deep-dives/two-model-architecture/#simple-explanation","title":"Simple Explanation","text":"<p>Use the big model to decide, and the small models/tools to do. One smart plan, many cheap steps.</p>"},{"location":"reference/deep-dives/two-model-architecture/#technical-explanation","title":"Technical Explanation","text":"<p>Planner (GPT-4o/Claude) generates a DAG once. Executors (Phi-3/Llama, MCP/tools/sandboxed code) run steps with retries/fallbacks and caching. Hybrid search narrows tools; guardrails keep cost, time, and failures controlled.</p> <p>ToolWeaver separates planning (large models) from execution (small models) to cut cost and latency.</p> <ul> <li>Planner: GPT-4o/Claude turn user intent into structured plans (1 call/request).</li> <li>Executors: Phi-3/Llama or deterministic tools perform parsing, routing, and enrichment (many cheap calls).</li> <li>Cost impact: 80\u201390% savings vs all-large-model by pushing repetitive work to small models + caching.</li> <li>Safety: planners see only necessary context; executors run in sandbox/process isolation.</li> </ul> <p>Execution flow 1) Plan: large model generates DAG with tool calls. 2) Search: registry search narrows tools (BM25 + embeddings). 3) Execute: small models/tools run steps; retries/fallbacks applied. 4) Aggregate: results merged; planner re-engaged only if needed.</p> <p>When to use - Workloads with many atomic steps (extraction, classification, routing). - Cost-sensitive pipelines needing predictable spend.</p> <p>Pitfalls / tips - Keep tool schemas tight to reduce planner token use. - Use caching (prompt/query/embedding) to avoid re-planning on similar inputs. - Prefer deterministic tools where possible; use small models for light reasoning, not heavy synthesis.</p>"},{"location":"reference/deep-dives/workflow-architecture/","title":"Workflow Architecture","text":""},{"location":"reference/deep-dives/workflow-architecture/#simple-explanation","title":"Simple Explanation","text":"<p>A plan becomes a graph of steps. We run ready steps in parallel with limits, retry on errors, and combine results.</p>"},{"location":"reference/deep-dives/workflow-architecture/#technical-explanation","title":"Technical Explanation","text":"<p>Planner outputs a DAG. Dispatcher executes ready nodes concurrently (<code>asyncio.gather</code>) under semaphores and budgets; applies retries/circuit breakers; sandboxes code; aggregates outputs; and emits metrics/logs with redaction.</p> <p>Execution is a DAG with guarded fan-out, retries, and fallbacks.</p> <p>Key components - Planner output \u2192 steps with dependencies, parameters, and stop conditions. - Dispatcher \u2192 runs ready nodes concurrently, enforces timeouts and budgets. - Safety rails \u2192 retry with backoff, circuit breakers, idempotency keys, redaction. - Sandboxed code \u2192 restricted builtins, no network, separate process.</p> <p>Flow 1) Validate plan (shape + limits). 2) Resolve tools via registry/search. 3) Execute ready steps in parallel (<code>asyncio.gather</code>), apply retries/fallbacks. 4) Aggregate outputs; short-circuit on fatal errors per policy.</p> <p>Tuning - Concurrency: cap fan-out to avoid runaway spend. - Timeouts: per-step + global; propagate cancellations. - Fallbacks: define alternates for flaky integrations.</p> <p>Observability - Metrics: success/failure, latency, cache hit rates. - Logs: structured with redaction; debug mode adds more detail safely.</p>"},{"location":"samples/","title":"Samples Index","text":"<p>Run these curated samples to see core features in action.</p>"},{"location":"samples/#prerequisites","title":"Prerequisites","text":"<ul> <li>Users: <code>pip install toolweaver</code></li> <li>If a sample has its own requirements file (e.g., REST client): <code>pip install -r samples/&lt;sample&gt;/requirements.txt</code></li> <li>Contributors (optional): <code>pip install -e .</code> to test against local source</li> </ul> <p>Note: <code>samples/</code> are the maintained, runnable demos. <code>examples/</code> contains older/extended scenarios\u2014start with <code>samples/</code> unless you need legacy material.</p> <ul> <li>Parallel Agents: samples/25-parallel-agents/parallel_deep_dive.py</li> <li>Caching Deep Dive: samples/07-caching-optimization/caching_deep_dive.py</li> <li>Sandbox Execution: samples/09-code-execution/code_execution_demo.py</li> <li>Adding Tools (3 ways): samples/23-adding-new-tools/three_ways.py</li> <li>GitHub Operations: samples/03-github-operations/github_ops.py</li> <li>Testing all samples: Testing guide</li> </ul> <p>Additional deep dives: - Skills Packaging &amp; Reuse: samples/30-skills-packaging/skills_demo.py - Plugin Extension: samples/31-plugin-extension/plugin_demo.py - Idempotency &amp; Retry (Dispatch): samples/32-idempotency-retry/idempotency_retry_demo.py - REST API Usage (client): samples/29-rest-api-usage/rest_client_demo.py</p>"},{"location":"samples/testing/","title":"Testing the Samples","text":"<p>How to run and validate the curated samples.</p>"},{"location":"samples/testing/#pre-checks","title":"Pre-checks","text":"<ul> <li>Verify dependencies: <code>python scripts/verify_install.py</code></li> <li>Ensure each sample has <code>.env</code> (copy from <code>.env.example</code> where provided) and <code>requirements.txt</code> installed.</li> </ul>"},{"location":"samples/testing/#run-a-single-sample","title":"Run a single sample","text":"<pre><code>cd samples/01-basic-receipt-processing\npython process_receipt.py\n</code></pre> <p>Expect: completes without import errors; outputs parsed receipt data.</p>"},{"location":"samples/testing/#run-all-samples-batch","title":"Run all samples (batch)","text":"<pre><code>cd samples\npython test_all_examples.py\n</code></pre> <p>What it does: discovers sample dirs, runs primary script with timeouts, reports success/failure summary.</p>"},{"location":"samples/testing/#envprovider-notes","title":"Env/provider notes","text":"<ul> <li>Basic/no-API samples: set <code>OCR_MODE=mock</code> when available (e.g., sample 01) to avoid external calls.</li> <li>LLM-required samples: set <code>OPENAI_API_KEY</code> or <code>AZURE_OPENAI_KEY</code> (e.g., 02, 10, 22).</li> <li>GitHub samples: set <code>GITHUB_TOKEN</code> (e.g., 03, 19, 20).</li> <li>Parallel/agent samples: watch async output and timing (e.g., 16, 17, 25).</li> </ul>"},{"location":"samples/testing/#verification-checklist-per-sample","title":"Verification checklist (per sample)","text":"<ul> <li>README present and purpose clear</li> <li>requirements installed</li> <li>.env configured</li> <li>Runs to completion (&lt;60s for basics) with sensible output</li> <li>Links in README work</li> </ul>"},{"location":"samples/testing/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Import error <code>No module named orchestrator</code>: run <code>pip install -e \" .[dev]\"</code> from repo root.</li> <li>Auth errors: populate <code>.env</code> with required keys.</li> <li>Hangs/timeouts: run with a timeout; check network/backends.</li> </ul>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Hands-on walkthroughs:</p> <ul> <li>Sandbox Execution</li> <li>Caching Deep Dive</li> <li>Parallel Agents</li> </ul>"},{"location":"tutorials/caching-deep-dive/","title":"Tutorial: Caching Deep Dive","text":""},{"location":"tutorials/caching-deep-dive/#simple-explanation","title":"Simple Explanation","text":"<p>Cache repeated work to save time and cost. When Redis is down, fallback kicks in automatically.</p>"},{"location":"tutorials/caching-deep-dive/#technical-explanation","title":"Technical Explanation","text":"<p>Multi-layer caching: catalog, embeddings, and query results with TTLs and a circuit breaker for Redis. ToolCache APIs manage keys and expiration. Prompt caching at providers reduces token costs.</p> <p>Explore Redis + file fallback, TTL, circuit breaker, and ToolCache API.</p> <p>Run:</p> <pre><code>python samples/07-caching-optimization/caching_deep_dive.py\npython samples/07-caching-optimization/caching_what_how_when.py\n</code></pre> <p>Prerequisites: - Install from PyPI: <code>pip install toolweaver</code></p> <p>Highlights: - Dual-layer cache with fallback when Redis is unavailable - TTL expiration demonstration - Circuit breaker protecting Redis outages - ToolCache keys for catalog/search/embeddings</p> <p>Files: - samples/07-caching-optimization/caching_deep_dive.py - samples/07-caching-optimization/caching_what_how_when.py - samples/07-caching-optimization/README.md</p>"},{"location":"tutorials/parallel-agents/","title":"Tutorial: Parallel Agents","text":""},{"location":"tutorials/parallel-agents/#simple-explanation","title":"Simple Explanation","text":"<p>Run many tools/agents at once with limits on cost and concurrency; combine results for a robust decision.</p>"},{"location":"tutorials/parallel-agents/#technical-explanation","title":"Technical Explanation","text":"<p>Fan-out dispatcher batches work under a semaphore (<code>max_parallel</code>), enforces budgets and failure-rate thresholds, applies idempotency for instant retries, and aggregates results via vote/rank/best.</p> <p>Fan out work with guardrails for cost, concurrency, and safety.</p> <p>Run:</p> <pre><code>python samples/25-parallel-agents/parallel_deep_dive.py\n</code></pre> <p>Prerequisites: - Install from PyPI: <code>pip install toolweaver</code></p> <p>What you will see: - Batch processing: 20 receipts in ~0.2s - Multi-model consensus with majority vote - Semaphore control batches work (max_parallel) - Quota protection stops cost bombs - Idempotency cache makes retries instant</p> <p>Files: - samples/25-parallel-agents/parallel_deep_dive.py - samples/25-parallel-agents/README.md</p>"},{"location":"tutorials/sandbox-execution/","title":"Tutorial: Sandbox Execution","text":""},{"location":"tutorials/sandbox-execution/#simple-explanation","title":"Simple Explanation","text":"<p>Safely run user-provided code: forbidden operations are blocked, outputs are captured, and long-running code is terminated.</p>"},{"location":"tutorials/sandbox-execution/#technical-explanation","title":"Technical Explanation","text":"<p>Sandboxed execution runs code in a restricted environment: limited builtins, no network, filtered environment, workspace-scoped file access, stdout/stderr capture, and timeouts/memory limits.</p> <p>Demonstrates isolated execution environments, restricted builtins, and timeouts.</p> <p>Run:</p> <pre><code>python samples/09-code-execution/code_execution_demo.py\n</code></pre> <p>Prerequisites: - Install from PyPI: <code>pip install toolweaver</code></p> <p>Shows: - Independent globals per sandbox - Forbidden builtins/modules blocked - STDOUT/STDERR capture - Timeout enforcement</p> <p>Files: - samples/09-code-execution/code_execution_demo.py - samples/09-code-execution/README.md</p>"}]}